/*
Navicat MySQL Data Transfer

Source Server         : mysql5.7
Source Server Version : 50719
Source Host           : localhost:3306
Source Database       : tblog

Target Server Type    : MYSQL
Target Server Version : 50719
File Encoding         : 65001

Date: 2018-03-08 20:39:18
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for t_attach
-- ----------------------------
DROP TABLE IF EXISTS `t_attach`;
CREATE TABLE `t_attach` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `fname` varchar(100) NOT NULL DEFAULT '',
  `ftype` varchar(50) DEFAULT '',
  `fkey` varchar(100) NOT NULL DEFAULT '',
  `author_id` int(10) DEFAULT NULL,
  `created` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_attach
-- ----------------------------
INSERT INTO `t_attach` VALUES ('2', '143149efzlr3xulr8tkm8w.jpg', 'image', '/upload/2018/03/vh0n7198q4iggo31h3vmqvu17s.jpg', '1', '1520399853');

-- ----------------------------
-- Table structure for t_comments
-- ----------------------------
DROP TABLE IF EXISTS `t_comments`;
CREATE TABLE `t_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `author_id` int(10) unsigned DEFAULT '0',
  `owner_id` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `content` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_comments
-- ----------------------------
INSERT INTO `t_comments` VALUES ('1', '6', '1497672195', 'tzs', '0', '1', '101011@gmail.com', 'http://juejin.im', '0:0:0:0:0:0:0:1', null, '棒棒哒，厉害了', 'comment', 'approved', '0');
INSERT INTO `t_comments` VALUES ('2', '6', '1497672339', 'tzs', '0', '1', '101011@gmail.com', 'http://juejin.im', '0:0:0:0:0:0:0:1', null, '再次评论，看看效果', 'comment', 'approved', '0');
INSERT INTO `t_comments` VALUES ('3', '5', '1497676424', 'tzs', '0', '1', '101011@gmail.com', 'http://juejin.im', '0:0:0:0:0:0:0:1', null, 'vswfwfwfw', 'comment', 'approved', '0');
INSERT INTO `t_comments` VALUES ('17', '15', '1520437725', 'zas', '0', '1', '', '', '0:0:0:0:0:0:0:1', null, '学习一下。', 'comment', 'approved', '0');
INSERT INTO `t_comments` VALUES ('18', '15', '1520437791', 'zhouas', '0', '1', '', '', '0:0:0:0:0:0:0:1', 'zas', '你好，请问怎末联系？', 'comment', 'approved', '17');
INSERT INTO `t_comments` VALUES ('19', '15', '1520438044', 'zas', '0', '1', '', '', '0:0:0:0:0:0:0:1', 'zhouas', '2183577510', 'comment', 'approved', '18');
INSERT INTO `t_comments` VALUES ('20', '15', '1520438815', 'zas', '0', '1', '', '', '0:0:0:0:0:0:0:1', null, '博客很好，可以借用这个模板吗？', 'comment', 'approved', '0');

-- ----------------------------
-- Table structure for t_contents
-- ----------------------------
DROP TABLE IF EXISTS `t_contents`;
CREATE TABLE `t_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `content` text COMMENT '内容文字',
  `author_id` int(10) unsigned DEFAULT '0',
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `tags` varchar(200) DEFAULT NULL,
  `categories` varchar(200) DEFAULT NULL,
  `hits` int(10) unsigned DEFAULT '0',
  `comments_num` int(10) unsigned DEFAULT '0',
  `allow_comment` tinyint(1) DEFAULT '1',
  `allow_ping` tinyint(1) DEFAULT '1',
  `allow_feed` tinyint(1) DEFAULT '1',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_contents
-- ----------------------------
INSERT INTO `t_contents` VALUES ('1', 'about my blog', 'about', '1487853610', '1520492578', '## About me\r\n    博主是一名本科计算机科学与技术专业大三学生，预计2019年6月毕业。\r\n\r\n    目前一事无成，前途未卜。\r\n\r\n    目标是互联网公司，Java后端，目前闭关修行中。\r\n\r\n    - [Github]( https://github.com/zas023)  \r\n    - [CSDN](http://blog.csdn.net/adminpd) \r\n\r\n## About Blog\r\n\r\n[Blog](https://github.com/zas023/pBlog)  modify from [Tale](https://github.com/otale/tale) , 是在 [Tale](https://github.com/otale/tale) 博客系统基础上进行修改的。\r\n\r\n`Tale` 使用了轻量级 mvc 框架 `Blade` 开发，默认主题使用了漂亮的 `pinghsu`打造的一个个人博客模板 。\r\n\r\n***\r\n\r\n[Blog](https://github.com/zas023/pBlog)   在  [Tale](https://github.com/otale/tale) 的基础上大量修改，采用的是 SpringBoot + Mybatis + thymeleaf  + MySQL 搭建的一个博客，其中在原来作者的基础上优化了。\r\n\r\n## 开源协议\r\n\r\n[MIT](./LICENSE)\r\n\r\n## 感谢\r\n\r\n[otale](https://github.com/otale)\r\n\r\n\r\n  [1]: https://github.com/zas023\r\n  [2]: https://github.com/zas023', '1', 'page', 'publish', null, null, '64', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('7', '【SSM】Spring+SpringMVC+mybatis入门（环境搭建）', null, '1520399995', '1520399995', '>已经大三了，想到快要工作实习，在大二时做了一个android APP的项目，最近和同学一起做一个项目，指导老师让我们用Spring框架，记录我自己学习ssm框架完成crud的整个过程。\r\n\r\n    开发环境windows+idea2017.1.5\r\n\r\n####1、新建一个maven项目\r\n    首先点击 File - New Project - 选择maven ，并且在右面选择maven-archtype-webapp选项，如图所示\r\n![这里写图片描述](http://img.blog.csdn.net/20171010194603030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n    \r\n    点击next后，出现填写GroupId和Artifactid，其中\r\n    1. GroupId写com.***.项目\r\n    2. Artifactid写你的项目名称\r\n\r\n    然后一直next即可\r\n\r\n#### 2.项目目录结构\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20171010195013951?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    其中java目录是自己添加，且设置为Sources Root。方法：选中目录->右键->Make Directory as->Sources Root。\r\n\r\n#### 3.配置文件\r\n*1.pom.xml*\r\n\r\n```\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <groupId>com.copasso</groupId>\r\n    <artifactId>ssmCrud</artifactId>\r\n    <packaging>war</packaging>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <name>ssmCrud Maven Webapp</name>\r\n    <url>http://maven.apache.org</url>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>3.8.1</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n\r\n        <!-- 引入项目依赖jar包 -->\r\n        <!-- spring， springMVC -->\r\n        <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-webmvc</artifactId>\r\n            <version>4.3.7.RELEASE</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-jdbc</artifactId>\r\n            <version>4.3.7.RELEASE</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects -->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-aspects</artifactId>\r\n            <version>4.3.7.RELEASE</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework/spring-test -->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n            <version>4.3.7.RELEASE</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n\r\n\r\n        <!-- Mybatis -->\r\n        <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis</artifactId>\r\n            <version>3.4.2</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis-spring</artifactId>\r\n            <version>1.3.1</version>\r\n        </dependency>\r\n\r\n        <!--数据库连接池 -->\r\n        <!-- https://mvnrepository.com/artifact/c3p0/c3p0 -->\r\n        <dependency>\r\n            <groupId>c3p0</groupId>\r\n            <artifactId>c3p0</artifactId>\r\n            <version>0.9.1</version>\r\n        </dependency>\r\n\r\n        <!--Mysql驱动 -->\r\n        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>5.1.41</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/jstl/jstl -->\r\n        <dependency>\r\n            <groupId>jstl</groupId>\r\n            <artifactId>jstl</artifactId>\r\n            <version>1.2</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api -->\r\n        <dependency>\r\n            <groupId>javax.servlet</groupId>\r\n            <artifactId>servlet-api</artifactId>\r\n            <version>2.5</version>\r\n            <scope>provided</scope>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core -->\r\n        <dependency>\r\n            <groupId>org.mybatis.generator</groupId>\r\n            <artifactId>mybatis-generator-core</artifactId>\r\n            <version>1.3.5</version>\r\n        </dependency>\r\n\r\n        <!-- 引入PageHelper插件 -->\r\n        <dependency>\r\n            <groupId>com.github.pagehelper</groupId>\r\n            <artifactId>pagehelper</artifactId>\r\n            <version>5.0.0</version>\r\n        </dependency>\r\n\r\n        <!-- 返回json字符串的支持 -->\r\n        <!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->\r\n        <dependency>\r\n            <groupId>com.fasterxml.jackson.core</groupId>\r\n            <artifactId>jackson-databind</artifactId>\r\n            <version>2.8.8</version>\r\n        </dependency>\r\n\r\n        <!--JSR303数据校验支持；tomcat7及以上的服务器， tomcat7以下的服务器：el表达式。额外给服务器的lib包中替换新的标准的el -->\r\n        <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator -->\r\n        <dependency>\r\n            <groupId>org.hibernate</groupId>\r\n            <artifactId>hibernate-validator</artifactId>\r\n            <version>5.4.1.Final</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core -->\r\n        <dependency>\r\n            <groupId>org.apache.shiro</groupId>\r\n            <artifactId>shiro-core</artifactId>\r\n            <version>1.4.0</version>\r\n        </dependency>\r\n        <!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-web -->\r\n        <dependency>\r\n            <groupId>org.apache.shiro</groupId>\r\n            <artifactId>shiro-web</artifactId>\r\n            <version>1.4.0</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.apache.poi/poi -->\r\n        <dependency>\r\n            <groupId>org.apache.poi</groupId>\r\n            <artifactId>poi</artifactId>\r\n            <version>3.17</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n            <version>4.1.3.RELEASE</version>\r\n        </dependency>\r\n    </dependencies>\r\n    <build>\r\n        <finalName>ssmCrud</finalName>\r\n    </build>\r\n</project>\r\n\r\n```\r\n\r\n*2.applicationContext.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\r\n	xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n	xsi:schemaLocation=\"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\r\n		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\r\n		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\r\n		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\">\r\n\r\n	<!--spring的配置文件,数据源，事务控制等 -->\r\n	<!--出现的问题是必须加下边的扫描，否则service包下的不能被当做bean -->\r\n	<context:component-scan base-package=\"com.copasso\">\r\n		<context:exclude-filter type=\"annotation\"\r\n			expression=\"org.springframework.stereotype.Controller\" />\r\n	</context:component-scan>\r\n\r\n	<context:property-placeholder location=\"classpath:dbconfig.properties\" />\r\n	<!--配置数据源 -->\r\n	<bean id=\"comboPooledDataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\r\n		<property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"></property>\r\n		<property name=\"driverClass\" value=\"${jdbc.driverClass}\"></property>\r\n		<property name=\"user\" value=\"${jdbc.user}\"></property>\r\n		<property name=\"password\" value=\"${jdbc.password}\"></property>\r\n	</bean>\r\n\r\n	<!--配置和Mybatis的整合 -->\r\n	<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n		<!--指定Mybatis全局配置文件 -->\r\n		<property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"></property>\r\n		<property name=\"dataSource\" ref=\"comboPooledDataSource\"></property>\r\n		<property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"></property>\r\n	</bean>\r\n\r\n	<!--配置扫描器 -->\r\n	<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n		<!--扫描所有dao接口的实现，加入到IOC容器中 -->\r\n		<property name=\"basePackage\" value=\"com.copasso.crud.dao\"></property>\r\n	</bean>\r\n\r\n	<!--执行批量的SQLSession -->\r\n	<bean id=\"sqlsession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\r\n		<constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></constructor-arg>\r\n		<constructor-arg name=\"executorType\" value=\"BATCH\"></constructor-arg>\r\n	</bean>\r\n\r\n	<!--事务控制的配置 -->\r\n	<bean id=\"transactionManager\"\r\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n		<!--控制住数据源 -->\r\n		<property name=\"dataSource\" ref=\"comboPooledDataSource\"></property>\r\n	</bean>\r\n\r\n	<!--开启基于注解的事务，使用XML配置形式的事务（推荐配置） -->\r\n	<aop:config>\r\n		<!--切入点表达式 -->\r\n		<aop:pointcut id=\"txPoint\"\r\n			expression=\"execution(* com.copasso.crud.service..*(..))\"></aop:pointcut>\r\n		<!--配置事务增强 -->\r\n		<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPoint\"></aop:advisor>\r\n	</aop:config>\r\n\r\n	<!--配置事务增强，事务如何切入 -->\r\n	<tx:advice id=\"txAdvice\">\r\n		<tx:attributes>\r\n			<tx:method name=\"*\" />\r\n			<!--以get开始的所有方法 -->\r\n			<tx:method name=\"get*\" read-only=\"true\" />\r\n		</tx:attributes>\r\n	</tx:advice>\r\n\r\n	<!--spring配置的核心点：数据源，和mybatis的整合 -->\r\n</beans>\r\n```\r\n\r\n\r\n\r\n*3.dispatcherServlet-servlet.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\r\n\r\n    <!--SpringMVC的配置，和网页跳转有关-->\r\n    <context:component-scan base-package=\"com.copasso\" use-default-filters=\"false\">\r\n        <!--只扫描控制器-->\r\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\r\n    </context:component-scan>\r\n\r\n    <!--视图解析器-->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <property name=\"prefix\" value=\"/WEB-INF/views/\"></property>\r\n        <property name=\"suffix\" value=\".jsp\"></property>\r\n    </bean>\r\n\r\n    <!--处理springMVC不能处理的静态资源-->\r\n    <mvc:default-servlet-handler/>\r\n    <!--处理一些spring的高级功能，如：JSR303，AJAX等-->\r\n    <mvc:annotation-driven/>\r\n\r\n</beans>\r\n```\r\n\r\n*4.web.xml*\r\n\r\n```\r\n<!--<!DOCTYPE web-app PUBLIC-->\r\n        <!--\"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"-->\r\n        <!--\"http://java.sun.com/dtd/web-app_2_3.dtd\" >-->\r\n<web-app>\r\n    <display-name>Archetype Created Web Application</display-name>\r\n\r\n    <!-- 1.启动Spring容器：业务逻辑 -->\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:applicationContext.xml\r\n        </param-value>\r\n    </context-param>\r\n    <listener>\r\n        <listener-class>org.springframework.web.context.ContextLoaderListener\r\n        </listener-class>\r\n    </listener>\r\n\r\n    <!-- 2.SpringMVC前端控制器：拦截所有请求 -->\r\n    <servlet>\r\n        <servlet-name>dispatcherServlet</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    </servlet>\r\n    <servlet-mapping>\r\n        <servlet-name>dispatcherServlet</servlet-name>\r\n        <url-pattern>/</url-pattern>\r\n    </servlet-mapping>\r\n\r\n    <!--字符编码过滤器-->\r\n    <filter>\r\n        <filter-name>characterEncodingFilter</filter-name>\r\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n        <init-param>\r\n            <param-name>encoding</param-name>\r\n            <param-value>utf-8</param-value>\r\n        </init-param>\r\n        <init-param>\r\n            <param-name>forceRequestEncoding</param-name>\r\n            <param-value>true</param-value>\r\n        </init-param>\r\n        <init-param>\r\n            <param-name>forceResponseEncoding</param-name>\r\n            <param-value>true</param-value>\r\n        </init-param>\r\n    </filter>\r\n    <filter-mapping>\r\n        <filter-name>characterEncodingFilter</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n\r\n    <!--配置Rest风格的过滤器，过滤请求为put请求和delete请求-->\r\n    <filter>\r\n        <filter-name>hiddenHttpMethodFilter</filter-name>\r\n        <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\r\n    </filter>\r\n    <filter-mapping>\r\n        <filter-name>hiddenHttpMethodFilter</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n\r\n    <!--配置PUT请求过滤器-->\r\n    <filter>\r\n        <filter-name>httpPutFormContentFilter</filter-name>\r\n        <filter-class>org.springframework.web.filter.HttpPutFormContentFilter</filter-class>\r\n    </filter>\r\n    <filter-mapping>\r\n        <filter-name>httpPutFormContentFilter</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n</web-app>\r\n\r\n```\r\n*5.配置mybatis-config.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n\r\n<configuration>\r\n	<settings>\r\n		<setting name=\"mapUnderscoreToCamelCase\" value=\"true\" />\r\n	</settings>\r\n	<typeAliases>\r\n		<package name=\"com.copasso.crud.bean\"></package>\r\n	</typeAliases>\r\n	<!--注册分页插件 -->\r\n	<plugins>\r\n		<plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\r\n			<property name=\"reasonable\" value=\"true\" />\r\n		</plugin>\r\n	</plugins>\r\n\r\n</configuration>\r\n```\r\n\r\n    其中还要新建一个dbconfig.properties文件，crud替换为你的数据库名\r\n\r\n```\r\njdbc.jdbcUrl=jdbc:mysql://localhost:3306/crud?useUnicode=true&characterEncoding=utf-8&useSSL=false\r\njdbc.driverClass=com.mysql.jdbc.Driver\r\njdbc.user=root\r\njdbc.password=admin\r\n```\r\n\r\n#### 4.最后的项目结构\r\n![这里写图片描述](http://img.blog.csdn.net/20171010200256982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n这样，三大框架整合完毕。。。', '1', 'post', 'publish', 'ssm,java', 'Java', '18', '1', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('9', '【Java】Java学习笔记-基础语法', null, '1520402610', '1520402610', '\r\n>一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。\r\n\r\n- 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\r\n- 类：类是一个模板，它描述一类对象的行为和状态。\r\n- 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。\r\n- 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。\r\n\r\n---\r\n###基本语法\r\n    编写Java程序时，应注意以下几点：\r\n\r\n- 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。\r\n- 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。\r\n- 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。\r\n- 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。\r\n- 主方法入口：所有的Java 程序由public static void main(String args[])方法开始执行。\r\n\r\n---\r\n\r\n###Java标识符\r\n   >Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。\r\n\r\n    关于Java标识符，有以下几点需要注意：\r\n\r\n    1. 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始\r\n       首字符之后可以是任何字符的组合\r\n    2. 关键字不能用作标识符\r\n    3. 标识符是大小写敏感的\r\n    4. 合法标识符举例：age、$salary、_value、__1_value\r\n       非法标识符举例：123abc、-salary\r\n\r\n---\r\n###Java修饰符\r\n    像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：\r\n\r\n    1. 可访问修饰符 : default, public , protected, private\r\n    2. 不可访问修饰符 : final, abstract, strictfp\r\n\r\n---\r\n###Java变量\r\n    Java中主要有如下几种类型的变量:\r\n局部变量\r\n类变量（静态变量）\r\n成员变量（非静态变量）\r\nJava数组\r\n数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。\r\n\r\n---\r\n###Java枚举\r\n>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。\r\n\r\n    注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。\r\n\r\n--- \r\n###Java关键字。\r\n\r\n关键字	| 描述\r\n:|:-\r\nabstract|	抽象方法，抽象类的修饰符\r\nassert|	断言条件是否满足\r\nboolean|	布尔数据类型\r\nbreak|	跳出循环或者label代码段\r\nbyte|	8-bit 有符号数据类型\r\ncase|	switch语句的一个条件\r\ncatch|	和try搭配捕捉异常信息\r\nchar|	16-bit Unicode字符数据类型\r\nclass|	定义类\r\nconst|	未使用\r\ncontinue|	不执行循环体剩余部分\r\ndefault|	switch语句中的默认分支\r\ndo|	循环语句，循环体至少会执行一次\r\ndouble|	64-bit双精度浮点数\r\nelse|	if条件不成立时执行的分支\r\nenum|	枚举类型\r\nextends|	表示一个类是另一个类的子类\r\nfinal|	表示一个值在初始化之后就不能再改变了，表示方法不能被重写，或者一个类不能有子类\r\nfinally|	为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。\r\nfloat|	32-bit单精度浮点数\r\nfor|	for循环语句\r\ngoto|	未使用\r\nif|	条件语句\r\nimplements|	表示一个类实现了接口\r\nimport|	导入类\r\ninstanceof|	测试一个对象是否是某个类的实例\r\nint|	32位整型数\r\ninterface|	接口，一种抽象的类型，仅有方法和常量的定义\r\nlong|	64位整型数\r\nnative|	表示方法用非java代码实现\r\nnew|	分配新的类实例\r\npackage|	一系列相关类组成一个包\r\nprivate|	表示私有字段，或者方法等，只能从类内部访问\r\nprotected|	表示字段只能通过类或者其子类访问，子类或者在同一个包内的其他类\r\npublic|	表示共有属性或者方法\r\nreturn|	方法返回值\r\nshort|	16位数字\r\nstatic|	表示在类级别定义，所有实例共享的\r\nstrictfp|	浮点数比较使用严格的规则\r\nsuper|	表示基类\r\nswitch|	选择语句\r\nsynchronized|	表示同一时间只能由一个线程访问的代码块\r\nthis|	表示调用当前实例或者调用另一个构造函数\r\nthrow|	抛出异常\r\nthrows|	定义方法可能抛出的异常\r\ntransient|	修饰不要序列化的字段\r\ntry|	表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码\r\nvoid|	标记方法不返回任何值\r\nvolatile|	标记字段可能会被多个线程同时访问，而不做同步\r\nwhile|	while循环\r\n\r\n---\r\n###Java注释\r\n>类似于C/C++，Java也支持单行以及多行注释。注释中的字符将被Java编译器忽略。\r\n\r\n###Java空行\r\n>空白行，或者有注释的的行，Java编译器都会忽略掉。\r\n', '1', 'post', 'publish', 'java', 'Java', '0', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('10', '【Java】Java学习笔记-变量和数据类型', null, '1520402661', '1520402803', '### Java 变量\r\n>变量是在内存中分配的保留区域的名称。换句话说，它是内存位置的名称。这意味着它的值可以改变。\r\n\r\n    在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：\r\n```\r\ntype identifier [ = value][, identifier [= value] ...] ;\r\n```\r\n    格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。\r\n    \r\n```\r\nint a=5;    // 这里 a就是一个变量。\r\n```\r\n\r\n#### 一、变量类型\r\n    java中有三种类型的变量：\r\n    \r\n    1. 局部变量(Local)：在方法内声明的变量称为局部变量。\r\n    2. 实例变量(Instance)：在类中声明但在方法外部的变量称为实例变量。但它不被声明为静态(未加static修辞符)。\r\n    3. 静态变量(Static)：被声明为static的变量(加static修辞符)称为静态变量。它不能是局部的。\r\n    \r\n```\r\nclass A{  \r\n    int a=5;//实例变量\r\n    static int m=10;// 静态变量\r\n    void method(){  \r\n        int n=9;//局部变量\r\n    }  \r\n}\r\n```\r\n---\r\n#### 二、局部变量\r\n    1. 局部变量声明在方法、构造方法或者语句块中；\r\n    2. 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\r\n    3. 访问修饰符不能用于局部变量；\r\n    4. 局部变量只在声明它的方法、构造方法或者语句块中可见；\r\n    5. 局部变量是在栈上分配的。\r\n    6. 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\r\n\r\n---\r\n#### 三、实例变量\r\n    1. 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\r\n    2. 当一个对象被实例化之后，每个实例变量的值就跟着确定；\r\n    3. 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\r\n    4. 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\r\n    5. 实例变量可以声明在使用前或者使用后；\r\n    6. 访问修饰符可以修饰实例变量；\r\n    7. 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\r\n    8. 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\r\n    9. 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\r\n    \r\n\r\n---\r\n#### 四、静态变量\r\n>静态变量也称类变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外。\r\n    \r\n    1. 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\r\n    2. 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。\r\n    3. 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。\r\n    4. 静态变量在程序开始时创建，在程序结束时销毁。\r\n    5. 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。\r\n    6. 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\r\n    7. 静态变量可以通过：ClassName.VariableName的方式访问。\r\n    8. 类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。\r\n\r\n###Java 基本数据类型\r\n>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\r\n内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。\r\n因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。\r\n\r\n    数据类型表示要存储在变量中的不同类型的值。 在Java中，有两种类型的数据类型：\r\n    1. **内置数据类型**\r\n    2. **引用数据类型**\r\n\r\n#### 一、内置数据类型\r\n>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\r\n   \r\n\r\n|数据类型         | 默认值           | 默认长度  |\r\n| ------------- |:-------------:| -----:|\r\nboolean|	false|	1 bit\r\nchar|	\'\\u0000\'|	2 byte\r\nbyte|	0|	1 byte\r\nshort|	0|	2 byte\r\nint|	0|	4 byte\r\nlong|	0L|	8 byte\r\nfloat|	0.0f|	4 byte\r\ndouble|	0.0d|	8 byte\r\n   \r\n###### (一) byte：\r\n\r\n    byte数据类型是8位、有符号的，以二进制补码表示的整数；\r\n      - 最小值是-128（-2^7）；\r\n      - 最大值是127（2^7-1）；\r\n      - 默认值是0；\r\n      - byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；\r\n\r\n###### (二) short：\r\n    short数据类型是16位、有符号的以二进制补码表示的整数\r\n    最小值是-32768（-2^15）；\r\n    最大值是32767（2^15 - 1）；\r\n    Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；\r\n    默认值是0；\r\n    \r\n######(三) int：\r\n    int数据类型是32位、有符号的以二进制补码表示的整数；\r\n    最小值是-2,147,483,648（-2^31）；\r\n    最大值是2,147,483,647（2^31 - 1）；\r\n    一般地整型变量默认为int类型；\r\n    默认值是0；\r\n    \r\n###### (四) long：\r\n    long数据类型是64位、有符号的以二进制补码表示的整数；\r\n    最小值是-9,223,372,036,854,775,808（-2^63）；\r\n    最大值是9,223,372,036,854,775,807（2^63 -1）；\r\n    这种类型主要使用在需要比较大整数的系统上；\r\n    默认值是0L；\r\n    exp: `long a = 100000L，long b = -200000L。`\r\n    \r\n###### (五) float：\r\n    float数据类型是单精度、32位、符合IEEE 754标准的浮点数；\r\n    float在储存大型浮点数组的时候可节省内存空间；\r\n    默认值是0.0f；\r\n    浮点数不能用来表示精确的值，如货币；\r\n\r\n###### (六) double：\r\n    double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\r\n    浮点数的默认类型为double类型；\r\n    double类型同样不能表示精确的值，如货币；\r\n    默认值是0.0d；\r\n\r\n###### (七) boolean：\r\n    boolean数据类型表示一位的信息；\r\n    只有两个取值：true和false；\r\n    这种类型只作为一种标志来记录true/false情况；\r\n    默认值是false；\r\n\r\n###### (八) char：\r\n    char类型是一个单一的16位Unicode字符；\r\n    最小值是’\\u0000’（即为0）；\r\n    最大值是’\\uffff’（即为65,535）；\r\n    char数据类型可以储存任何字符；\r\n\r\n>注：为什么char在java中使用2个字节以及什么是\\u0000 ？\r\n\r\n    这是因为java使用Unicode系统而非ASCII码系统编码。 \\u0000是Unicode系统的最低范围。\r\n\r\n---\r\n###### 案例\r\n```\r\n//测试原始数据类型\r\npublic class PrimitiveType{\r\n    public static void main(String[] args) {\r\n        // byte\r\n        System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE);\r\n        System.out.println(\"包装类：java.lang.Byte\");\r\n        System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE);\r\n        System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE);\r\n        System.out.println();\r\n        // short\r\n        System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE);\r\n        System.out.println(\"包装类：java.lang.Short\");\r\n        System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE);\r\n        System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE);\r\n        System.out.println();\r\n        // int\r\n        System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE);\r\n        System.out.println(\"包装类：java.lang.Integer\");\r\n        System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE);\r\n        System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\r\n        System.out.println();\r\n        // long\r\n        System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE);\r\n        System.out.println(\"包装类：java.lang.Long\");\r\n        System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE);\r\n        System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE);\r\n        System.out.println();\r\n        // float\r\n        System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE);\r\n        System.out.println(\"包装类：java.lang.Float\");\r\n        System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE);\r\n        System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE);\r\n        System.out.println();\r\n\r\n        // double\r\n        System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE);\r\n        System.out.println(\"包装类：java.lang.Double\");\r\n        System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE);\r\n        System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE);\r\n        System.out.println();\r\n\r\n        // char\r\n        System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE);\r\n        System.out.println(\"包装类：java.lang.Character\");\r\n        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台\r\n        System.out.println(\"最小值：Character.MIN_VALUE=\"\r\n            + (int) Character.MIN_VALUE);\r\n        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台\r\n        System.out.println(\"最大值：Character.MAX_VALUE=\"\r\n            + (int) Character.MAX_VALUE);\r\n    }\r\n}  \r\n```\r\n\r\n```\r\n//溢出\r\npublic class AddExample{  \r\n    public static void main(String[] args){  \r\n        int a=130;  \r\n        byte b=(byte)a;  \r\n        System.out.println(a);  //a=130\r\n        System.out.println(b);  //b=-126\r\n    }\r\n}\r\n```\r\n\r\n```\r\n//较低类型相加\r\npublic class AddExample{  \r\n    public static void main(String[] args){  \r\n        byte a=10;  \r\n        byte b=10;  \r\n        //byte c=a+b;\r\n        //Compile Time Error: 因为a+b=20将会变成int类型 \r\n        //错误: 不兼容的类型: 从int转换到byte可能会有损失\r\n        byte c=(byte)(a+b);  \r\n        System.out.println(c);  \r\n    }\r\n}\r\n```\r\n\r\n>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。\r\n\r\n#### 二、引用类型\r\n- 引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。\r\n- 对象、数组都是引用数据类型。\r\n- 所有引用类型的默认值都是null。\r\n- 一个引用变量可以用来引用与任何与之兼容的类型。\r\n\r\n```\r\n//例子：\r\nBoy boy = new Boy(“Tom”);\r\n```\r\n\r\n---\r\n### Java常量\r\n    常量就是一个固定值。它们不需要计算，直接代表相应的值。\r\n\r\n```\r\n//常量指不能改变的量。 在Java中用final标志，声明方式和变量类似：\r\nfinal double PI = 3.1415927;\r\n```\r\n\r\n    虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。\r\n\r\n```\r\n//字面量可以赋给任何内置类型的变量。例如：\r\nbyte a = 68;\r\nchar a = \'A\'\r\n```\r\n\r\n    byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。\r\n\r\n```\r\n//当使用常量的时候，前缀0表明是8进制，而前缀0x代表16进制。例如：\r\nint decimal = 100;\r\nint octal = 0144;\r\nint hexa =  0x64;\r\n```\r\n    和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。\r\n```\r\n//下面是字符串型字面量的例子：\r\n\"Hello World\"\r\n\"two\\nlines\"\r\n\"\\\"This is in quotes\\\"\"\r\n```\r\n\r\n    字符串常量和字符常量都可以包含任何Unicode字符。\r\n```\r\nchar a = \'\\u0001\';\r\nString a = \"\\u0001\";\r\n```\r\n\r\n###### Java语言支持一些特殊的转义字符序列。\r\n\r\n|符号         | 字符含义           |\r\n| ------------- |:-------------:|\r\n\\n|	换行 (0x0a)\r\n\\r|	回车 (0x0d)\r\n\\f|	换页符(0x0c)\r\n\\b| 退格 (0x08)\r\n\\s|	空格 (0x20)\r\n\\t|	制表符\r\n\\\"|	双引号\r\n\\\'|	单引号\r\n\\ |反斜杠\r\n\\ddd| 八进制字符 (ddd)\r\n\\uxxxx|	16进制Unicode字符 (xxxx)\r\n', '1', 'post', 'publish', 'java', 'Java', '2', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('11', '【Java】Java学习笔记-修饰符', null, '1520402697', '1520402697', '###Java 修饰符\r\n>修饰符用来定义类、方法或者变量，通常放在语句的最前端。\r\n\r\n    Java语言提供了很多修饰符，主要分为以下两类：\r\n    1. 访问修饰符\r\n    2. 非访问修饰符\r\n\r\n---\r\n#####一、访问控制修饰符\r\n>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。\r\n\r\n- 默认的，也称为default，在同一包内可见，不使用任何修饰符。\r\n\r\n- 私有的，以private修饰符指定，在同一类内可见。\r\n\r\n- 共有的，以public修饰符指定，对所有类可见。\r\n\r\n- 受保护的，以protected修饰符指定，对同一包内的类和所有子类可见。\r\n\r\n######访问控制和继承\r\n\r\n    1. 父类中声明为public的方法在子类中也必须为public。\r\n\r\n    2. 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。\r\n\r\n    3. 父类中默认修饰符声明的方法，能够在子类中声明为private。\r\n\r\n    4. 父类中声明为private的方法，不能够被继承。\r\n\r\n---\r\n\r\n#####二、非访问修饰符\r\n>为了实现一些其他的功能，Java也提供了许多非访问修饰符。\r\n\r\n- static修饰符，用来创建类方法和类变量。\r\n\r\n        静态变量：声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。\r\n        静态方法：声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\r\n\r\n- Final修饰符，用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\r\n\r\n```\r\npublic class FinalExample{\r\n  final int value = 10;\r\n  // 下面是声明常量的实例\r\n  public static final int BOXWIDTH = 6;\r\n  static final String TITLE = \"Manager\";\r\n\r\n  public void changeValue(){\r\n     value = 12; //将输出一个错误\r\n  }\r\n}\r\n```\r\n    类中的Final方法可以被子类继承，但是不能被子类修改。\r\n    声明final方法的主要目的是防止该方法的内容被修改。\r\n```\r\npublic class FinalExample{\r\n    public final void changeName(){\r\n       // 方法体\r\n    }\r\n}\r\n```\r\n\r\n- Abstract修饰符，用来创建抽象类和抽象方法。\r\n\r\n> 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\r\n\r\n    1. 一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。\r\n        \r\n    2. 抽象类可以包含抽象方法和非抽象方法。\r\n\r\n```\r\nabstract class AbstractExample{\r\n   private double price;\r\n   private String model;\r\n   private String year;\r\n   public abstract void goFast(); //抽象方法\r\n   public abstract void changeColor();\r\n}\r\n```\r\n\r\n>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和static。\r\n\r\n    1. 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。\r\n\r\n    2. 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。\r\n    \r\n```\r\npublic abstract class FatherClass{\r\n    abstract void m(); //抽象方法\r\n}\r\n \r\nclass SubClass extends FatherClass{\r\n     //实现抽象方法\r\n      void m(){\r\n          .........\r\n      }\r\n}\r\n```\r\n\r\n- Synchronized关键字声明的方法同一时间只能被一个线程访问。\r\n\r\n>Synchronized修饰符可以应用于四个访问修饰符。\r\n\r\n- Transient修饰符\r\n\r\n>序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。\r\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。\r\n\r\n- volatile修饰符\r\n\r\n>Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。\r\n\r\n```\r\npublic class MyRunnable implements Runnable\r\n{\r\n    private volatile boolean active;\r\n    public void run()\r\n    {\r\n        active = true;\r\n        while (active) // line 1\r\n        {\r\n            // 代码\r\n        }\r\n    }\r\n    public void stop()\r\n    {\r\n        active = false; // line 2\r\n    }\r\n}\r\n```\r\n\r\n', '1', 'post', 'publish', 'java', 'Java', '0', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('12', '【Java】Java学习笔记-运算符', null, '1520402725', '1520402725', '####Java运算符\r\n>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：\r\n\r\n#####1. 算术运算符\r\n\r\n    算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算。\r\n    (表格中的实例假设整数变量A的值为10，变量B的值为20)\r\n```\r\n\r\n```\r\n\r\n操作符|描述|例子\r\n- | :-: | :-: \r\n+|	加法 - 相加运算符两侧的值|	A + B等于30\r\n-|	减法 - 左操作数减去右操作数|	A – B等于-10\r\n*|	乘法 - 相乘操作符两侧的值|	A * B等于200\r\n/|	除法 - 左操作数除以右操作数|	B / A等于2\r\n％|	取模 - 左操作数除以右操作数的余数|	B%A等于0\r\n++|	自增 - 操作数的值增加1|	B++ 或 ++B 等于 21\r\n--|	自减 - 操作数的值减少1|	B-- 或 --B 等于 19\r\n\r\n---\r\n\r\n#####2.关系运算符\r\n操作符|描述|例子\r\n- | :-: | :-: \r\n==|	检查如果两个操作数的值是否相等，如果相等则条件为真。|（A == B）为假(非真)\r\n!=|	检查如果两个操作数的值是否相等，如果值不相等则条件为真。| (A != B) 为真\r\n\\> |	检查左操作数的值是否大于右操作数的值，如果是那么条件为真。|（A>B）非真\r\n<|	检查左操作数的值是否小于右操作数的值，如果是那么条件为真。|（A < B）为真\r\n\\>=| 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。|（A>= B）为假\r\n<=|检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。|（A <= B）为真\r\n\r\n \r\n    1. 逻辑|| 如果第一个条件为真(true)，运算符不检查第二个条件。它只在第一个条件为假(false)时才会检查第二个条件。\r\n\r\n    2. 按位或 | 运算符总是检查两个条件，不管第一个条件是真(true)还是假(false)。\r\n    \r\n---\r\n\r\n#####3.位运算符\r\n操作符|描述|例子\r\n- | :-: | :-: \r\n＆|	按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。|	（A＆B），得到12，即0000 1100\r\n\\||	按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。|	（A \\| B）得到61，即 0011 1101\r\n^|	按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。|	（A ^ B）得到49，即 0011 0001\r\n〜|	按位补运算符翻转操作数的每一位。|	（〜A）得到-60，即1100 0011\r\n<< |	按位左移运算符。左操作数按位左移右操作数指定的位数。|	A << 2得到240，即 1111 0000\r\n\\>>| 	按位右移运算符。左操作数按位右移右操作数指定的位数。|	A >> 2得到15即 1111\r\n\\>>> |	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。|	A>>>2得到15即0000 1111\r\n\r\n#####4.逻辑运算符\r\n操作符|描述|例子\r\n- | :-: | :-: \r\n&&|	称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。|	（A && B）为假。\r\n\\|\\|	|称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。|（A \\|\\| B）为真。\r\n！|	称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。|！（A && B）为真。\r\n\r\n#####5.赋值运算符\r\n操作符|描述|例子\r\n- | :-: | :-: \r\n=|	简单的赋值运算符，将右操作数的值赋给左侧操作数|	C = A + B将把A + B得到的值赋给C\r\n+ =|	加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数|	C + = A等价于C = C + A\r\n- =|	减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数|	C - = A等价于C = C - A\r\n* =|	乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数|	C * = A等价于C = C * A\r\n/ =|	除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数|	C / = A等价于C = C / A\r\n（％）=|	取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数|	C％= A等价于C = C％A\r\n<< =|	左移位赋值运算符|	C << = 2等价于C = C << 2\r\n\\>\\> =	|右移位赋值运算符|	C >> = 2等价于C = C >> 2\r\n＆=|	按位与赋值运算符|	C＆= 2等价于C = C＆2\r\n^ =|	按位异或赋值操作符|	C ^ = 2等价于C = C ^ 2\r\n| =|	按位或赋值操作符|	C \\| = 2等价于C = C\\| 2\r\n\r\n#####6.其他运算符\r\n操作符|描述|例子\r\n- | :-: | :-: \r\n条件运算符（?:）|条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。|variable x = (expression) ? value if true : value if false\r\ninstanceOf|该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。|( Object reference variable ) instanceOf  (class/interface type)\r\n\r\n```\r\nString name = \'Tom\';\r\nboolean result = name instanceOf String; // 由于name是Strine类型，所以返回真\r\n\r\n/*******************************************************/\r\n\r\nclass Vehicle {}\r\npublic class Car extends Vehicle {\r\n   public static void main(String args[]){\r\n      Vehicle a = new Car();\r\n      boolean result =  a instanceof Car;\r\n      System.out.println( result);\r\n   }\r\n}\r\n```\r\n---\r\n####Java运算符优先级\r\n>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。\r\n\r\n类别|操作符|关联性\r\n- | :-: | :-: \r\n后缀|	() [] . (点操作符)|	左到右\r\n一元|	\\+ + - ！〜|	从右到左\r\n乘性 |	\\* / ％	|左到右\r\n加性 |	\\+ -	|左到右\r\n移位| 	\\>\\> >>>  << |	左到右\r\n关系| 	\\>\\> = << =| 	左到右\r\n相等| 	==  !=|	左到右\r\n按位与|	＆|	左到右\r\n按位异或|	^|	左到右\r\n按位或|	\\| |	左到右\r\n逻辑与|	&&	|左到右\r\n逻辑或|	\\|\\|	|左到右\r\n条件|	？：|	从右到左\r\n赋值	|= + = - = * = / =％= >> = << =＆= ^ = \\| =	|从右到左\r\n逗号	|，|	左到右', '1', 'post', 'publish', 'java', 'Java', '3', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('13', '【Java】Java学习笔记-控制语句', null, '1520406125', '1520406125', '###Java 循环结构\r\n>顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。\r\n\r\n    Java中有三种主要的循环结构：\r\n    1. while循环\r\n    2. do…while循环\r\n    3. for循环\r\n\r\n#####(一)while循环\r\n>while是最基本的循环，用于重复程序的一部分几次或重复执行一个代码块。 如果迭代次数不固定，建议使用while循环。\r\n\r\n```\r\nwhile(condition){  \r\n    //code to be executed  \r\n}\r\n```\r\n    只要布尔表达式为true，循环体会一直执行下去。\r\n\r\n#####(二)do…while循环\r\n>对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\r\n\r\n    do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。\r\n\r\n```\r\ndo{  \r\n    //code to be executed  \r\n}while(condition); // 后置条件检查\r\n```\r\n\r\n    注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为true，则语句块一直执行，直到布尔表达式的值为false。\r\n\r\n#####(三)for循环\r\n>虽然所有循环结构都可以用while或者do...while表示，但Java提供了另一种语句 —— for循环，使一些循环结构变得更加简单。\r\n\r\n    for循环执行的次数是在执行前就确定的。语法格式如下：\r\n\r\n```\r\nfor(initialization;condition;incr/decr){  \r\n    //code to be executed  \r\n}\r\n```\r\n    关于for循环有以下几点说明：\r\n\r\n    1. 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\r\n    2. 然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。\r\n    3. 执行一次循环后，更新循环控制变量。\r\n    4. 再次检测布尔表达式。循环执行上面的过程。\r\n    \r\n#####(四)for-each循环\r\n>for-each循环用于在java中遍历数组或集合。它比简单的for循环更容易使用，因为不需要递增值和使用下标符号。\r\n\r\n```\r\nfor(Type var:array){  \r\n   //code to be executed  \r\n}\r\n```\r\n#####(五)标记For循环\r\n>我们可以让每个for循环的名称。 为此，在for循环之前使用标签。它是有用的，如果在嵌套for循环中，可以使用break/continue指定循环。\r\n\r\n    通常，break和continue关键字断开/继续最内循环。\r\n  \r\n\r\n```\r\n//语法：\r\nlabelname:  \r\nfor(initialization;condition;incr/decr){  \r\n    //code to be executed  \r\n}\r\n\r\n//示例：\r\npublic class LabeledForExample  {\r\n    public static void main(String[] args) {\r\n        aa: for (int i = 1; i <= 3; i++) {\r\n            bb: for (int j = 1; j <= 3; j++) {\r\n                if (i == 2 && j == 2) {\r\n                    break aa;\r\n                }\r\n                System.out.println(i + \" \" + j);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n####break关键字\r\n>break主要用在循环语句或者switch语句中，用来跳出整个语句块。\r\n\r\n    break跳出最里层的循环，并且继续执行该循环下面的语句。\r\n\r\n####continue关键字\r\n>continue适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\r\n\r\n    在for循环中，continue语句使程序立即跳转到更新语句。\r\n\r\n    在while或者do…while循环中，程序立即跳转到布尔表达式的判断语句。\r\n\r\n---\r\n\r\n###Java 分支结构\r\n>顺序结构只能顺序执行，不能进行判断和选择，因此需要分支结构。\r\n\r\n    Java有两种分支结构：\r\n    1. if语句\r\n    2. switch语句\r\n#####(一)if语句\r\n>if语句用于测试条件。它检查布尔条件为：true或false。\r\n\r\n```\r\nif(condition){  \r\n   // if 语句块 => code to be executed.\r\n}\r\n```\r\n#####(二)if-else语句\r\n>if-else语句也用于测试条件。如果if条件为真(true)它执行if块中的代码，否则执行else块中的代码。\r\n```\r\nif(condition){  \r\n    //code if condition is true  \r\n}else{  \r\n    //code if condition is false  \r\n}\r\n```\r\n#####(三)if-else-if语句\r\n>Java编程中的if-else-if语句是从多个语句中执行一个条件。\r\n\r\n```\r\nif(condition1){  \r\n    //code to be executed if condition1 is true  \r\n}else if(condition2){  \r\n    //code to be executed if condition2 is true  \r\n}else if(condition3){  \r\n    //code to be executed if condition3 is true  \r\n}  \r\n...  \r\nelse{  \r\n    //code to be executed if all the conditions are false  \r\n}\r\n```\r\n\r\n    使用if，else if，else语句的时候，需要注意下面几点：\r\n\r\n    1. if语句至多有1个else语句，else语句在所有的elseif语句之后。\r\n    2. If语句可以有若干个elseif语句，它们必须在else语句之前。\r\n    3. 一旦其中一个else if语句检测为true，其他的else if以及else语句都将跳过执行。 \r\n\r\n#####(四)switch语句\r\n>switch语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。它就像if-else-if语句一样。\r\n```\r\nswitch(expression){    \r\n    case value1:    \r\n       //code to be executed;    \r\n       break;  //optional  \r\n    case value2:    \r\n       //code to be executed;    \r\n       break;  //optional  \r\n    ......    \r\n\r\n    default:     \r\n       // code to be executed if all cases are not matched;    \r\n}\r\n```\r\n\r\n    switch语句有如下规则：\r\n\r\n    1. switch语句中的变量类型只能为byte、short、int或者char。\r\n    2. switch语句可以拥有多个case语句。每个case后面跟一个要比较的值和冒号。\r\n    3. case语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\r\n    4. 当变量的值与case语句的值相等时，那么case语句之后的语句开始执行，直到break语句出现才会跳出switch语句。\r\n    5. 当遇到break语句时，switch语句终止。程序跳转到switch语句后面的语句执行。case语句不必须要包含break语句。如果没有break语句出现，程序会继续执行下一条case语句，直到出现break语句。\r\n    6. switch语句可以包含一个default分支，该分支必须是switch语句的最后一个分支。default在没有case语句的值和变量值相等的时候执行。default分支不需要break语句。\r\n\r\n>switch语句落空通过所有条件，即 case 子句中的所有条件都未能匹配。也就是如果不在 switch case 下使用break语句，则它在第一个匹配之后也会执行接下来的所有 case 中的语句。\r\n```\r\npublic class SwitchExample {\r\n    public static void main(String[] args) {\r\n        int number = 20;\r\n        switch (number) {\r\n        case 10:\r\n            System.out.println(\"10\");\r\n        case 20:\r\n            System.out.println(\"20\");\r\n        case 30:\r\n            System.out.println(\"30\");\r\n        default:\r\n            System.out.println(\"Not in 10, 20 or 30\");\r\n        }\r\n    }\r\n}\r\n\r\n//输出\r\n20\r\n30\r\nNot in 10, 20 or 30\r\n```', '1', 'post', 'publish', 'java', 'Java', '0', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('14', '【Java】Java学习笔记-对象和类', null, '1520406161', '1520406161', '### Java 对象和类\r\n>Java作为一种面向对象语言。支持以下基本概念：\r\n    1. 多态\r\n    2. 继承\r\n    3. 封装\r\n    5. 抽象\r\n    6. 类\r\n    7. 对象\r\n    8. 实例\r\n    9. 方法\r\n    10. 消息解析\r\n\r\n\r\n- 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\r\n- 类：类是一个模板，它描述一类对象的行为和状态。\r\n\r\n---\r\n#### 1. Java中的对象\r\n>具有状态和行为的实体可称为对象(女朋友也可以叫对象)。 椅子，自行车，标记，笔，桌子，汽车等。它可以是物理或逻辑(有形和无形)。 无形对象的例子是银行系统。\r\n\r\n    一个对象有三个特点：\r\n\r\n- 状态： 表示一个对象的数据(值)。\r\n- 行为： 表示对象的行为(功能)，例如：存款，取款等。\r\n- 标识： 对象标识通常通过唯一ID实现。该ID的值对外部用户不可见。 但是，它由JVM内部使用来唯一地标识每个对象。\r\n\r\n    例如： 汽车是一个对象。它的名字是：捷达，颜色是白色等这些就是它的状态(数据值)。它用于跑路，所以跑路就是它的行为。\r\n\r\n>对象是类的一个实例。 类是创建对象的模板或蓝图。 所以对象是一个类的实例。\r\n\r\n    对象定义：\r\n\r\n- 对象是一个现实世界的实体。\r\n- 对象是一个运行时实体。\r\n- 对象是具有状态和行为的实体。\r\n- 对象是类的一个实例。\r\n\r\n---\r\n\r\n#### 2. Java中的类\r\n>类是具有共同属性的一组对象。它是创建对象的模板或蓝图。它是一个逻辑实体。 它不能是物理存在的实体。\r\n\r\n    Java中的类可以包含：\r\n\r\n- 字段\r\n- 方法\r\n- 构造函数\r\n- 代码块\r\n- 嵌套类和接口\r\n\r\n``` Java\r\n//声明一个类的语法：\r\nclass <class_name>{  \r\n    field;  \r\n    method;  \r\n}\r\n```\r\n\r\n##### 2.1. Java中的实例变量\r\n>实例变量在类内部，但在方法外部定义的变量称为实例变量。 实例变量在编译时不获取内存。 它在运行时获取对象(实例)创建时的内存。 这是为什么，它被称为实例变量。\r\n\r\n##### 2.2. Java中的方法\r\n>在java中的方法类似函数，用于暴露对象的行为。\r\n\r\n    方法的优点\r\n\r\n- 代码可重用性\r\n- 代码优化\r\n\r\n##### 2.3. Java中的new关键字\r\n>new关键字用于在运行时分配内存。所有对象在堆内存区域中获取内存。\r\n\r\n#### 2.4构造方法\r\n>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。\r\n\r\n    在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\r\n\r\n``` Java\r\n//下面是一个构造方法示例：\r\npublic class Puppy{\r\n   public Puppy(){\r\n   }\r\n\r\n   public Puppy(String name){\r\n      // 这个构造器仅有一个参数：name\r\n   }\r\n}\r\n```\r\n\r\n#### 2.5创建对象\r\n    对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：\r\n\r\n- 声明：声明一个对象，包括对象名称和对象类型。\r\n- 实例化：使用关键字new来创建一个对象。\r\n- 初始化：使用new创建对象时，会调用构造方法初始化对象。\r\n\r\n``` Java\r\n//下面是一个创建对象的例子：\r\npublic class Puppy{\r\n   public Puppy(String name){\r\n      //这个构造器仅有一个参数：name\r\n      System.out.println(\"Passed Name is :\" + name ); \r\n   }\r\n   public static void main(String []args){\r\n      // 下面的语句将创建一个Puppy对象\r\n      Puppy myPuppy = new Puppy( \"tommy\" );\r\n   }\r\n}\r\n\r\n//编译并运行上面的程序，会打印出下面的结果：\r\nPassed Name is :tommy\r\n```\r\n\r\n#### 在Java中创建对象的不同方法有哪些？\r\n    在java中有很多方法可以用来创建对象。它们分别是：\r\n\r\n- 通过new关键字\r\n- 通过newInstance()方法\r\n- 通过clone()方法\r\n- 通过反序列化\r\n- 通过工厂方法等\r\n- 在接下来的章节中，将学习这些方法用来创建对象。\r\n\r\n#### 匿名对象\r\n    匿名只是表示没有名。没有引用的对象(也就是不使用实例变量)称为匿名对象。它只能在创建对象时使用。如果只需要使用一个对象，匿名对象是一个很好的方法。 例如：\r\n\r\n``` Java\r\nnew Puppy();//匿名对象\r\nPuppy p = new Puppy();// 使用实例变量，所以不是匿名对象\r\n```\r\n\r\n---\r\n\r\n### 源文件声明规则\r\n>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。\r\n\r\n- 一个源文件中只能有一个public类\r\n- 一个源文件可以有多个非public类\r\n- 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。\r\n- 如果一个类定义在某个包中，那么package语句应该在源文件的首行。\r\n- 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。\r\n- import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\r\n- 类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。\r\n\r\n    除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。\r\n\r\n---\r\n### Java包\r\n>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。\r\n\r\n---\r\n### Import语句\r\n>在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。\r\n\r\n``` Java\r\n//例如，下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类\r\nimport java.io.*;\r\n```\r\n\r\n### 一个简单的例子\r\n\r\n``` Java\r\nclass Employee{\r\n    String name;\r\n    int age;\r\n    String designation;\r\n    double salary;\r\n    // Employee 类的构造器\r\n    public Employee(String name){\r\n        this.name = name;\r\n    }\r\n    // 设置age的值\r\n    public void empAge(int empAge){\r\n        age =  empAge;\r\n    }\r\n    /* 设置designation的值*/\r\n    public void empDesignation(String empDesig){\r\n        designation = empDesig;\r\n    }\r\n    /* 设置salary的值*/\r\n    public void empSalary(double empSalary){\r\n        salary = empSalary;\r\n    }\r\n    /* 打印信息 */\r\n    public void printEmployee(){\r\n        System.out.println(\"Name:\"+ name );\r\n        System.out.println(\"Age:\" + age );\r\n        System.out.println(\"Designation:\" + designation );\r\n        System.out.println(\"Salary:\" + salary);\r\n    }\r\n}\r\n\r\npublic class EmployeeExample {\r\n\r\n    public static void main(String args[]){\r\n        /* 使用构造器创建两个对象 */\r\n        Employee empOne = new Employee(\"James Smith\");\r\n        Employee empTwo = new Employee(\"Mary Anne\");\r\n\r\n        // 调用这两个对象的成员方法\r\n        empOne.empAge(26);\r\n        empOne.empDesignation(\"Senior Software Engineer\");\r\n        empOne.empSalary(1000);\r\n        empOne.printEmployee();\r\n\r\n        empTwo.empAge(21);\r\n        empTwo.empDesignation(\"Software Engineer\");\r\n        empTwo.empSalary(500);\r\n        empTwo.printEmployee();\r\n    }\r\n}\r\n\r\n//运行结果：\r\nName:James Smith\r\nAge:26\r\nDesignation:Senior Software Engineer\r\nSalary:1000.0\r\nName:Mary Anne\r\nAge:21\r\nDesignation:Software Engineer\r\nSalary:500.0\r\n```\r\n\r\n### Java面向对象（OOP）概念\r\n>对象意味着真实的单词实体，如：笔，椅子，表等。面向对象编程是一种使用类和对象来设计程序的方法或模式。 它通过提供一些概念简化了软件开发和维护：\r\n\r\n- 对象: 任何具有状态和行为的实体都称为对象。 例如：椅子，钢笔，桌子，键盘，自行车等。它可以是物理和逻辑的。\r\n- 类: 对象的集合称为类。 它是一个逻辑实体。\r\n- 继承: 当一个对象获取父对象的所有属性和行为，称为继承。 它提供代码可重用性。 它用于实现运行时多态性。\r\n- 多态性: 当一个任务通过不同的方式执行时，称为多态性。 例如：以不同的方式说服客户，画一些东西，如：形状或矩形等。\r\n- 抽象: 隐藏内部细节和显示功能称为抽象。 例如：电话，但我们不知道内部是如何处理通话/通信的。\r\n- 封装: 将代码和数据绑定(或包装)在一起成为单个单元称为封装。 例如：胶囊，它包裹着不同的药物。\r\n\r\n>OOP的优点相对于面向过程的编程语言\r\n\r\n- OOP使开发和维护变得更容易，因为在面向过程的编程语言中，如果代码随着项目规模的增长而增长，则不容易管理。\r\n\r\n- OOP提供数据隐藏，而在面向过程的编程语言中，可以从任何地方访问全局数据。\r\n\r\n- OOP提供更有效地模拟真实世界事件的能力。 如果使用面向对象的编程语言，我们可以提供真实世界里的问题的解决方案。\r\n\r\n', '1', 'post', 'publish', 'java', 'Java', '2', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('15', '【Java】Java学习笔记-面向对象', null, '1520406211', '1520406211', '### 一 Java构造器（构造方法）\r\n>java中的构造方法是一种特殊类型的方法，用于初始化对象。Java构造函数在对象创建时被调用。 它构造值，即提供对象的数据，这是为什么它被称为构造函数。\r\n\r\n    创建java构造函数的规则:\r\n\r\n- 构造函数名称必须与其类名称相同\r\n- 构造函数必须没有显式返回类型\r\n\r\n>有两种类型的构造函数：\r\n\r\n    1. 默认构造函数(无参数构造函数)\r\n    2. 参数化构造函数\r\n\r\n#### 1. 默认构造函数(无参数构造函数)\r\n\r\n``` Java\r\n//没有参数的构造函数称为默认构造函数。默认构造函数的语法如下：\r\n<class_name>(){}\r\n\r\n//默认构造函数的示例：\r\nclass Bike {\r\n    Bike() {\r\n        System.out.println(\"Bike is created\");\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        Bike b = new Bike();\r\n    }\r\n}\r\n\r\n//上面的示例代码运行结果如下 -\r\nBike is created\r\n```\r\n\r\n    规则：\r\n    1. 如果类中没有构造函数，编译器会自动创建一个默认构造函数。\r\n    2. 默认构造函数根据类型为对象提供默认值，如：0，null等。 \r\n    3. 构造函数返回当前类的实例(不能指定返回值类型，但它会返回一个值)。\r\n\r\n#### 2. 构造函数和方法之间的区别\r\n\r\n|构造函数|Java方法|\r\n :-: | -: |\r\n构造器用于初始化对象的状态(数据)。|	方法用于暴露对象的行为。\r\n构造函数不能有返回类型。|	方法一般都有返回类型。\r\n构造函数隐式调用。|	方法要显式调用。\r\n如果没有指定任何构造函数，java编译器提供一个默认构造函数。|	在任何情况下编译器都不会提供默认的方法调用。\r\n构造函数名称必须与类名称相同。|	方法名称可以或可以不与类名称相同(随意)。\r\n\r\n### 二 Java 继承\r\n>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。\r\n\r\n    Java中的继承是一种机制，表示为一个对象获取父对象的所有属性和行为。\r\n\r\n- 在Java中继承是：可以创建基于现有类构建新的类。 当您从现有类继承时，就可以重复使用父类的方法和字段，也可以在继承的新类中添加新的方法和字段。\r\n\r\n- 继承表示IS-A关系，也称为父子关系，是说:一个对象是另一个对象的一个分类。\r\n\r\n---\r\n    如果类A是类B的父类，而类B是类C的父类，我们也称C是A的子类，类C是从类A继承而来的。在Java中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类\r\n\r\n    继承中最常使用的两个关键字是extends和implements。\r\n\r\n    这两个关键字的使用决定了一个对象和另一个对象是否是IS-A(是一个)关系。\r\n\r\n    通过使用这两个关键字，我们能实现一个对象获取另一个对象的属性。\r\n\r\n    所有Java的类均是由java.lang.Object类继承而来的，所以Object是所有类的祖先类，而除了Object外，所有类必须有一个父类。\r\n\r\n#### 1. 为什么在java中使用继承？\r\n    对于方法覆盖(因此可以实现运行时的多态性)，提高代码可重用性。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写(覆盖)。\r\n\r\n#### 2. 继承的语法\r\n\r\n```\r\nclass Subclass-name extends Superclass-name  \r\n{  \r\n   //methods and fields  \r\n}\r\n```\r\n\r\n    extends关键字表示正在从现有类派生创建的新类。 “extends”的含义是增加功能。在Java的术语中，继承的类称为父类或超类，新类称为子或子类。\r\n\r\n#### 3. java继承类型\r\n\r\n##### 3.1. 单一继承示例\r\n\r\n``` Java\r\nclass Animal {\r\n    void eat() {\r\n        System.out.println(\"eating...\");\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    void bark() {\r\n        System.out.println(\"barking...\");\r\n    }\r\n}\r\n\r\nclass TestInheritance {\r\n    public static void main(String args[]) {\r\n        Dog d = new Dog();\r\n        d.bark();\r\n        d.eat();\r\n    }\r\n}\r\n\r\n//执行上面代码得到以下结果 \r\n\r\nbarking...\r\neating...\r\n```\r\n\r\n##### 3.2 多级继承示例\r\n``` Java\r\nclass Animal {\r\n    void eat() {\r\n        System.out.println(\"eating...\");\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    void bark() {\r\n        System.out.println(\"barking...\");\r\n    }\r\n}\r\n\r\nclass BabyDog extends Dog {\r\n    void weep() {\r\n        System.out.println(\"weeping...\");\r\n    }\r\n}\r\n\r\nclass TestInheritance2 {\r\n    public static void main(String args[]) {\r\n        BabyDog d = new BabyDog();\r\n        d.weep();\r\n        d.bark();\r\n        d.eat();\r\n    }\r\n}\r\n\r\n//执行上面代码得到以下结果 -\r\n\r\nweeping...\r\nbarking...\r\neating...\r\n```\r\n\r\n##### 3.3 多级继承示例\r\n\r\n``` Java\r\nclass Animal {\r\n    void eat() {\r\n        System.out.println(\"eating...\");\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    void bark() {\r\n        System.out.println(\"barking...\");\r\n    }\r\n}\r\n\r\nclass Cat extends Animal {\r\n    void meow() {\r\n        System.out.println(\"meowing...\");\r\n    }\r\n}\r\n\r\nclass TestInheritance3 {\r\n    public static void main(String args[]) {\r\n        Cat c = new Cat();\r\n        c.meow();\r\n        c.eat();\r\n        // c.bark();//C.T.Error\r\n    }\r\n}\r\n\r\n//执行上面代码得到以下结果 -\r\n\r\nmeowing...\r\neating...\r\n```\r\n\r\n>为什么在Java中不支持多重继承？\r\n\r\n    为了降低复杂性并简化语言，Java中不支持多重继承。想象一个：A，B和C是三个类。 C类继承A和B类。 如果A和B类有相同的方法，并且从子类对象调用它，A或B类的调用方法会有歧义。\r\n \r\n```\r\nclass A {\r\n    void msg() {\r\n        System.out.println(\"Hello\");\r\n    }\r\n}\r\n\r\nclass B {\r\n    void msg() {\r\n        System.out.println(\"Welcome\");\r\n    }\r\n}\r\n\r\nclass C extends A,B\r\n{//suppose if it were  \r\n\r\n Public Static\r\n\r\n    void main(String args[]) {\r\n        C obj = new C();\r\n        obj.msg();// Now which msg() method would be invoked?\r\n    }\r\n}\r\n```\r\n      编译时错误比运行时错误好，如果继承2个类，java会在编译时报告错误。 所以无论子类中是否有相同的方法，都会有报告编译时错误。例如下面的代码是编译出错的。\r\n\r\n### 三 聚合\r\n>如果一个类有一个类的实体引用(类中的类)，则它称为聚合。 聚合表示HAS-A关系。\r\n\r\n    何时使用聚合？\r\n    \r\n- 当没有is-a关系时，通过聚合也能最好地实现代码重用。\r\n- 只有在所涉及的对象的整个生命周期内维持关系为is-a时，才应使用继承; 否则，聚合是最好的选择。\r\n\r\n``` Java\r\n//Address.java\r\npublic class Address {\r\n    String city, province;\r\n\r\n    public Address(String city, String province) {\r\n        this.city = city;\r\n        this.province = province;\r\n    }\r\n\r\n}\r\n\r\n//Emp.java\r\npublic class Emp {\r\n    int id;\r\n    String name;\r\n    Address address;\r\n\r\n    public Emp(int id, String name, Address address) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.address = address;\r\n    }\r\n\r\n    void display() {\r\n        System.out.println(id + \" \" + name);\r\n        System.out.println(address.city + \" \" + address.province);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Address address1 = new Address(\"广州\", \"广东\");\r\n        Address address2 = new Address(\"海口\", \"海南\");\r\n\r\n        Emp e = new Emp(111, \"Wang\", address1);\r\n        Emp e2 = new Emp(112, \"Zhang\", address2);\r\n\r\n        e.display();\r\n        e2.display();\r\n\r\n    }\r\n}\r\n\r\n//执行上面代码，得到以下结果 -\r\n\r\n111 Wang\r\n广州 广东\r\n112 Zhang\r\n海口 海南\r\n```\r\n\r\n### 四 重写(Override)与重载(Overload)\r\n\r\n#### 1.重写\r\n>如果子类中具有与父类中声明相同的方法，在java中称为方法覆盖。换句话说，如果子类提供了由其父类提供的其中一个方法的特定实现，则它被称为方法覆盖。所以方法覆盖有两个前提条件：继承和子父类中方法名称相同。\r\n\r\n    Java方法覆盖的用法\r\n\r\n- 方法重写用于提供有别于超类提供的方法的特定实现。\r\n- 方法重写用于运行时多态性。\r\n\r\n---  \r\n    Java方法覆盖的规则\r\n\r\n- 方法必须与父类中的名称相同。\r\n- 方法必须具有与父类中相同的参数。\r\n- 必须是IS-A关系(继承)。\r\n\r\n##### 1.1 理解没有方法覆盖的问题\r\n``` Java\r\n//如果在程序中不使用方法覆盖可能面临的问题。\r\n\r\nclass Vehicle {\r\n    void run() {\r\n        System.out.println(\"Vehicle is running\");\r\n    }\r\n}\r\n\r\nclass Bike extends Vehicle {\r\n\r\n    public static void main(String args[]) {\r\n        Bike obj = new Bike();\r\n        obj.run();\r\n    }\r\n}\r\n\r\n//执行上面代码，输出结果如下 -\r\n\r\nVehicle is running\r\n```\r\n    问题是，必须在子类中提供一个run()方法，这就是为什么要使用方法覆盖。\r\n``` Java\r\n//方法覆盖的示例\r\n//在下面的这个例子中，在父类中和子类中都定义了run方法，但子类中有一些特定的实现。 方法的名称和参数是相同的，并且类之间有IS-A关系，因此这里run方法被覆盖了。\r\n\r\nclass Vehicle {\r\n    void run() {\r\n        System.out.println(\"Vehicle is running\");\r\n    }\r\n}\r\n\r\nclass Bike2 extends Vehicle {\r\n    void run() {\r\n        System.out.println(\"Bike is running safely\");\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        Bike2 obj = new Bike2();\r\n        obj.run();\r\n    }\r\n}\r\n\r\n//执行输出结果如下 -\r\n\r\nBike is running safely\r\n```\r\n\r\n>可以覆盖静态方法吗？\r\n\r\n    这是不可以的，静态方法不能被覆盖。\r\n    因为静态方法是绑定类，而实例方法绑定对象。 静态属于类区域，实例属于堆区域。\r\n\r\n#### 2. 重载\r\n>如果一个类中有多个具有相同名称但参数不同的方法，则称为方法重载。如果只需要执行一个操作，具有相同的方法名称将增加程序的可读性。\r\n假设必须执行给定数值的添加操作(求和)，但是参数的数量不固定，如果为两个参数编写add1(int，int)方法，为三个参数编写add2(int，int，int)方法，可能对其他程序员来说很难理解这样的方法的行为，因为它的名称不同。\r\n因此，执行方法重载能比较容易理解程序含义。\r\n\r\n    方法重载的优点\r\n\r\n- 方法重载提高了程序的可读性。\r\n- 重载方法不同的方式\r\n\r\n---\r\n    在java中重载方法有两种方式，它们分别是：\r\n\r\n- 通过改变参数的数量\r\n- 通过更改数据类型\r\n\r\n---\r\n    注意：在java中，只通过更改方法的返回类型来实现方法重载是不可以的。\r\n\r\n\r\n``` Java\r\nclass Adder {\r\n    static int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n    static int add(int a, int b, int c) {\r\n        return a + b + c;\r\n    }\r\n    static double add(double a, double b) {\r\n        return a + b;\r\n    }\r\n}\r\n\r\nclass TestOverloading2 {\r\n    public static void main(String[] args) {\r\n        System.out.println(Adder.add(11, 11));\r\n        System.out.println(Adder.add(12.3, 12.6));\r\n    }\r\n}\r\n\r\n//上面代码执行后，输出结果如下 -\r\n\r\n22\r\n24.9\r\n```\r\n\r\n>为什么方法重载不能通过更改方法的返回类型？\r\n\r\n    在java中，只通过改变方法的返回类型来实现方法重载是不可能的，因为这样具有模糊性。 让我们来看看模糊性是怎么样发生的：\r\n\r\n``` Java\r\nclass Adder {\r\n    static int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n\r\n    static double add(int a, int b) {\r\n        return a + b;\r\n    }\r\n}\r\n\r\nclass TestOverloading3 {\r\n    public static void main(String[] args) {\r\n        System.out.println(Adder.add(11, 11));// ambiguity\r\n    }\r\n}\r\n\r\n//上面代码执行后，输出结果如下 -\r\n\r\nCompile Time Error: method add(int,int) is already defined in class Adder\r\nJava\r\n```\r\n\r\nSystem.out.println(Adder.add(11,11));//这里，java如何确定应该调用哪个sum()方法？\r\n\r\n    注意：编译时错误优于运行时错误。 所以，如果你声明相同的方法具有相同的参数，java编译器渲染编译器时间错误。\r\n\r\n>可以重载java main()方法吗？\r\n\r\n    这是完全可以的。 可以通过方法重载在类中有任意数量的main方法。 但是JVM调用main()方法，它只接收字符串数组作为参数。 让我们来看一个简单的例子：\r\n\r\n``` Java\r\nclass TestOverloading4{  \r\n    public static void main(String[] args){System.out.println(\"main with String[]\");}  \r\n    public static void main(String args){System.out.println(\"main with String\");}  \r\n    public static void main(){System.out.println(\"main without args\");}  \r\n}\r\n\r\n//上面代码执行后，输出结果如下 -\r\n\r\nmain with String[]\r\n```\r\n\r\n#### 方法重载和方法重写的区别\r\n|方法重载|方法重写|\r\n :-: | -: |\r\n方法重载用于提高程序的可读性。|	方法重写用于提供已经由其超类提供的方法的特定实现。\r\n方法重载在类内执行。|	方法重写发生在具有IS-A(继承)关系的两个类中。\r\n在方法重载的情况下，参数必须不同。|	在方法重写的情况下，参数必须相同。\r\n方法重载是编译时多态性的例子。|	方法重写/覆盖是运行时多态性的例子。\r\n方法重载不能仅通过改变方法的返回类型来执行。方法重载中的返回类型可以相同或不同。 但是必须更改参数类型。|	在方法重写/覆盖中返回类型必须相同或协变。\r\n\r\n### 五 多态\r\n>多态是同一个行为具有多个不同表现形式或形态的能力。\r\n\r\n    多态性是对象多种表现形式的体现。\r\n\r\n    比如我们说\"宠物\"这个对象，它就有很多不同的表达或实现，比如有小猫、小狗、蜥蜴等等。那么我到宠物店说\"请给我一只宠物\"，服务员给我小猫、小狗或者蜥蜴都可以，我们就说\"宠物\"这个对象就具备多态性。\r\n\r\n``` Java\r\n//例子\r\npublic interface Vegetarian{}\r\npublic class Animal{}\r\npublic class Deer extends Animal implements Vegetarian{}\r\n```\r\n\r\n    因为Deer类具有多重继承，所以它具有多态性。以上实例解析如下：\r\n\r\n- 一个 Deer IS-A（是一个） Animal\r\n- 一个 Deer IS-A（是一个） Vegetarian\r\n- 一个 Deer IS-A（是一个） Deer\r\n- 一个 Deer IS-A（是一个）Object\r\n\r\n---\r\n    在Java中，所有的对象都具有多态性，因为任何对象都能通过IS-A测试的类型和Object类。\r\n\r\n    1. 访问一个对象的唯一方法就是通过引用型变量。\r\n\r\n    2. 引用型变量只能有一种类型，一旦被声明，引用型变量的类型就不能被改变了。\r\n\r\n    3. 引用型变量不仅能够被重置为其他对象，前提是这些对象没有被声明为final。还可以引用和它类型相同的或者相兼容的对象。它可以声明为类类型或者接口类型。\r\n\r\n``` Java\r\n//当我们将引用型变量应用于Deer对象的引用时，下面的声明是合法的：\r\n\r\nDeer d = new Deer();\r\nAnimal a = d;\r\nVegetarian v = d;\r\nObject o = d;\r\n//所有的引用型变量d,a,v,o都指向堆中相同的Deer对象。\r\n```\r\n\r\n#### 虚方法\r\n>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。\r\n\r\n    要想调用父类中被重写的方法，则必须使用关键字super。\r\n\r\n``` Java\r\npublic class Employee\r\n{\r\n   private String name;\r\n   private String address;\r\n   private int number;\r\n   public Employee(String name, String address, int number)\r\n   {\r\n      System.out.println(\"Constructing an Employee\");\r\n      this.name = name;\r\n      this.address = address;\r\n      this.number = number;\r\n   }\r\n   public void mailCheck()\r\n   {\r\n      System.out.println(\"Mailing a check to \" + this.name\r\n       + \" \" + this.address);\r\n   }\r\n   public String toString()\r\n   {\r\n      return name + \" \" + address + \" \" + number;\r\n   }\r\n   public String getName()\r\n   {\r\n      return name;\r\n   }\r\n   public String getAddress()\r\n   {\r\n      return address;\r\n   }\r\n   public void setAddress(String newAddress)\r\n   {\r\n      address = newAddress;\r\n   }\r\n   public int getNumber()\r\n   {\r\n     return number;\r\n   }\r\n}\r\n```\r\n\r\n``` Java\r\npublic class Salary extends Employee\r\n{\r\n   private double salary; //Annual salary\r\n   public Salary(String name, String address, int number, double\r\n      salary)\r\n   {\r\n       super(name, address, number);\r\n       setSalary(salary);\r\n   }\r\n   public void mailCheck()\r\n   {\r\n       System.out.println(\"Within mailCheck of Salary class \");\r\n       System.out.println(\"Mailing check to \" + getName()\r\n       + \" with salary \" + salary);\r\n   }\r\n   public double getSalary()\r\n   {\r\n       return salary;\r\n   }\r\n   public void setSalary(double newSalary)\r\n   {\r\n       if(newSalary >= 0.0)\r\n       {\r\n          salary = newSalary;\r\n       }\r\n   }\r\n   public double computePay()\r\n   {\r\n      System.out.println(\"Computing salary pay for \" + getName());\r\n      return salary/52;\r\n   }\r\n}\r\n```\r\n\r\n    现在我们仔细阅读下面的代码，尝试给出它的输出结果：\r\n\r\n``` Java\r\npublic class VirtualDemo\r\n{\r\n   public static void main(String [] args)\r\n   {\r\n      Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta, UP\", 3, 3600.00);\r\n      Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2, 2400.00);\r\n      System.out.println(\"Call mailCheck using Salary reference --\");\r\n      s.mailCheck();\r\n      System.out.println(\"\\n Call mailCheck using Employee reference--\");\r\n      e.mailCheck();\r\n    }\r\n}\r\n\r\n//以上实例编译运行结果如下：\r\nConstructing an Employee\r\nConstructing an Employee\r\nCall mailCheck using Salary reference --\r\nWithin mailCheck of Salary class\r\nMailing check to Mohd Mohtashim with salary 3600.0\r\n\r\nCall mailCheck using Employee reference--\r\nWithin mailCheck of Salary class\r\nMailing check to John Adams with salary 2400.0\r\n```\r\n\r\n    例子中，我们实例化了两个Salary对象。一个使用Salary引用s，另一个使用Employee引用。\r\n    编译时，编译器检查到mailCheck()方法在Salary类中的声明。\r\n\r\n    在调用s.mailCheck()时，Java虚拟机(JVM)调用Salary类的mailCheck()方法。\r\n\r\n    因为e是Employee的引用，所以调用e的mailCheck()方法则有完全不同的结果。\r\n\r\n    当编译器检查e.mailCheck()方法时，编译器检查到Employee类中的mailCheck()方法。\r\n\r\n    在编译的时候，编译器使用Employee类中的mailCheck()方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是Salary类中的mailCheck()方法。\r\n\r\n    该行为被称为虚拟方法调用，该方法被称为虚拟方法。\r\n\r\n    Java中所有的方法都能以这种方式表现，借此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。\r\n\r\n### 六 抽象类\r\n>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\r\n\r\n    抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\r\n    \r\n    由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\r\n    \r\n    父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\r\n\r\n### 七 封装\r\n>在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。\r\n\r\n    封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\r\n\r\n    要访问该类的代码和数据，必须通过严格的接口控制。\r\n\r\n    封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\r\n\r\n### 八 接口\r\n>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\r\n\r\n    接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\r\n\r\n    除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\r\n\r\n    接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\r\n\r\n---\r\n    接口与类相似点：\r\n\r\n- 一个接口可以有多个方法。\r\n- 接口文件保存在.java结尾的文件中，文件名使用接口名。\r\n- 接口的字节码文件保存在.class结尾的文件中。\r\n- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 \r\n\r\n---\r\n    接口与类的区别：\r\n- 接口不能用于实例化对象。\r\n- 接口没有构造方法。\r\n- 接口中所有的方法必须是抽象方法。\r\n- 接口不能包含成员变量，除了static和final变量。\r\n- 接口不是被类继承了，而是要被类实现。\r\n- 接口支持多重继承。\r\n\r\n#### 8.1 接口的声明\r\n\r\n```\r\n[可见度] interface 接口名称 [extends 其他的类名] {\r\n        // 声明变量\r\n        // 抽象方法\r\n}\r\n\r\npublic interface NameOfInterface\r\n{\r\n   //任何类型 final, static 字段\r\n   //抽象方法\r\n}\r\n```\r\n    接口有以下特性：\r\n- 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。\r\n- 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。\r\n- 接口中的方法都是公有的。\r\n\r\n#### 8.2 接口的实现\r\n>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\r\n\r\n    类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。\r\n\r\n``` Java\r\n//实现一个接口的语法，可以使用这个公式：\r\n\r\n... implements 接口名称[, 其他接口, 其他接口..., ...] ...\r\n\r\n//实例：\r\npublic class MammalInt implements Animal{\r\n\r\n   public void eat(){\r\n      System.out.println(\"Mammal eats\");\r\n   }\r\n\r\n   public void travel(){\r\n      System.out.println(\"Mammal travels\");\r\n   } \r\n\r\n   public int noOfLegs(){\r\n      return 0;\r\n   }\r\n\r\n   public static void main(String args[]){\r\n      MammalInt m = new MammalInt();\r\n      m.eat();\r\n      m.travel();\r\n   }\r\n} \r\n\r\n//以上实例编译运行结果如下:\r\nMammal eats\r\nMammal travels\r\n```\r\n    重写接口中声明的方法时，需要注意以下规则：\r\n\r\n- 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。\r\n- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。\r\n- 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。\r\n\r\n---\r\n    在实现接口的时候，也要注意一些规则：\r\n\r\n- 一个类可以同时实现多个接口。\r\n- 一个类只能继承一个类，但是能实现多个接口。\r\n- 一个接口能继承另一个接口，这和类之间的继承比较相似。\r\n\r\n#### 8.3 接口的继承\r\n>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。\r\n\r\n    在Java中，类的多重继承是不合法，但接口允许多重继承，。\r\n\r\n``` Java\r\n//在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口:\r\n\r\npublic interface Hockey extends Sports, Event\r\n```\r\n#### 8.4 标记接口\r\n>最常用的继承接口是没有包含任何方法的接口。\r\n\r\n    标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。\r\n\r\n    标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。\r\n\r\n``` Java\r\n//例如：java.awt.event包中的MouseListener接口继承的java.util.EventListener接口定义如下：\r\npackage java.util;\r\npublic interface EventListener\r\n{}\r\n```\r\n\r\n    没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\r\n\r\n- 建立一个公共的父接口：\r\n        \r\n        正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\r\n\r\n- 向一个类添加数据类型：\r\n    \r\n        这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\r\n', '1', 'post', 'publish', 'java', 'Java', '176', '16', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('16', '【Java】Java学习笔记-多线程', null, '1520479513', '1520479513', '> Java给多线程编程提供了内置的支持。一个多线程程序包含两个或多个能并发运行的部分。程序的每一部分都称作一个线程，并且每个线程定义了一个独立的执行路径。\r\n\r\n    多线程是多任务的一种特别的形式。多线程比多任务需要更小的开销。\r\n\r\n    这里定义和线程相关的另一个术语：进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。\r\n\r\n    多线程能满足程序员编写非常有效率的程序来达到充分利用CPU的目的，因为CPU的空闲时间能够保持在最低限度。\r\n\r\n#### 一个线程的生命周\r\n> 线程经过其生命周期的各个阶段。下图显示了一个线程完整的生命周期。\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20180226153619391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n- 新建状态: 一个新产生的线程从新状态开始了它的生命周期。它保持这个状态直到程序start这个线程。\r\n\r\n- 运行状态:当一个新状态的线程被start以后，线程就变成可运行状态，一个线程在此状态下被认为是开始执行其任务\r\n\r\n- 就绪状态:当一个线程等待另外一个线程执行一个任务的时候，该线程就进入就绪状态。当另一个线程给就绪状态的线程发送信号时，该线程才重新切换到运行状态。\r\n\r\n- 休眠状态: 由于一个线程的时间片用完了，该线程从运行状态进入休眠状态。当时间间隔到期或者等待的时间发生了，该状态的线程切换到运行状态。\r\n\r\n- 终止状态: 一个运行状态的线程完成任务或者其他终止条件发生，该线程就切换到终止状态。\r\n\r\n#### 线程的优先级\r\n>每一个Java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java优先级在MIN_PRIORITY（1）和MAX_PRIORITY（10）之间的范围内。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。\r\n\r\n    具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。\r\n\r\n#### 1. 创建一个线程\r\n    Java提供了两种创建线程方法：\r\n\r\n1. 通过实现Runnable接口；\r\n\r\n2. 通过继承Thread类本身。\r\n\r\n##### 通过实现Runnable接口来创建线程\r\n> 创建一个线程，最简单的方法是创建一个实现Runnable接口的类。\r\n\r\n``` Java\r\n// 创建一个新的线程\r\nclass NewThread implements Runnable {\r\n   Thread t;\r\n   NewThread() {\r\n      // 创建第二个新线程\r\n      t = new Thread(this, \"Demo Thread\");\r\n      System.out.println(\"Child thread: \" + t);\r\n      t.start(); // 开始线程\r\n   }\r\n  \r\n   // 第二个线程入口\r\n   public void run() {\r\n      try {\r\n         for(int i = 5; i > 0; i--) {\r\n            System.out.println(\"Child Thread: \" + i);\r\n            // 暂停线程\r\n            Thread.sleep(50);\r\n         }\r\n     } catch (InterruptedException e) {\r\n         System.out.println(\"Child interrupted.\");\r\n     }\r\n     System.out.println(\"Exiting child thread.\");\r\n   }\r\n}\r\n \r\npublic class ThreadDemo {\r\n   public static void main(String args[]) {\r\n      new NewThread(); // 创建一个新线程\r\n      try {\r\n         for(int i = 5; i > 0; i--) {\r\n           System.out.println(\"Main Thread: \" + i);\r\n           Thread.sleep(100);\r\n         }\r\n      } catch (InterruptedException e) {\r\n         System.out.println(\"Main thread interrupted.\");\r\n      }\r\n      System.out.println(\"Main thread exiting.\");\r\n   }\r\n}\r\n\r\n//编译以上程序运行结果如下：\r\n\r\nChild thread: Thread[Demo Thread,5,main]\r\nMain Thread: 5\r\nChild Thread: 5\r\nChild Thread: 4\r\nMain Thread: 4\r\nChild Thread: 3\r\nChild Thread: 2\r\nMain Thread: 3\r\nChild Thread: 1\r\nExiting child thread.\r\nMain Thread: 2\r\nMain Thread: 1\r\nMain thread exiting.\r\n\r\n```\r\n\r\n##### 2. 通过继承Thread来创建线程\r\n> 创建一个线程的第二种方法是创建一个新的类，该类继承Thread类，然后创建一个该类的实例。\r\n\r\n    继承类必须重写run()方法，该方法是新线程的入口点。它也必须调用start()方法才能执行。\r\n\r\n``` Java\r\n// 通过继承 Thread 创建线程\r\nclass NewThread extends Thread {\r\n   NewThread() {\r\n      // 创建第二个新线程\r\n      super(\"Demo Thread\");\r\n      System.out.println(\"Child thread: \" + this);\r\n      start(); // 开始线程\r\n   }\r\n \r\n   // 第二个线程入口\r\n   public void run() {\r\n      try {\r\n         for(int i = 5; i > 0; i--) {\r\n            System.out.println(\"Child Thread: \" + i);\r\n            // 让线程休眠一会\r\n            Thread.sleep(50);\r\n         }\r\n      } catch (InterruptedException e) {\r\n         System.out.println(\"Child interrupted.\");\r\n      }\r\n      System.out.println(\"Exiting child thread.\");\r\n   }\r\n}\r\n \r\npublic class ExtendThread {\r\n   public static void main(String args[]) {\r\n      new NewThread(); // 创建一个新线程\r\n      try {\r\n         for(int i = 5; i > 0; i--) {\r\n            System.out.println(\"Main Thread: \" + i);\r\n            Thread.sleep(100);\r\n         }\r\n      } catch (InterruptedException e) {\r\n         System.out.println(\"Main thread interrupted.\");\r\n      }\r\n      System.out.println(\"Main thread exiting.\");\r\n   }\r\n}\r\n\r\n//编译以上程序运行结果如下：\r\n\r\nChild thread: Thread[Demo Thread,5,main]\r\nMain Thread: 5\r\nChild Thread: 5\r\nChild Thread: 4\r\nMain Thread: 4\r\nChild Thread: 3\r\nChild Thread: 2\r\nMain Thread: 3\r\nChild Thread: 1\r\nExiting child thread.\r\nMain Thread: 2\r\nMain Thread: 1\r\nMain thread exiting.\r\n\r\n```\r\n\r\n#### Thread 方法\r\n|方法名称|方法描述|\r\n-|-|\r\nstart()|使该线程开始执行；Java 虚拟机调用该线程的 run 方法。\r\nrun()|如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。\r\nsetName(String name)|改变线程名称，使之与参数 name 相同。\r\nsetPriority(int priority)|更改线程的优先级。\r\nsetDaemon(boolean on)|将该线程标记为守护线程或用户线程。\r\njoin(long millisec)|等待该线程终止的时间最长为 millis 毫秒。\r\ninterrupt()|中断线程。\r\nisAlive()|测试线程是否处于活动状态。\r\n\r\n    几个静态方法：\r\n|方法名称|方法描述|\r\n-|-|\r\npublic static void yield()|暂停当前正在执行的线程对象，并执行其他线程。\r\npublic static void sleep(long millisec)|在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。\r\npublic static boolean holdsLock(Object x)|当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。\r\npublic static Thread currentThread()|返回对当前正在执行的线程对象的引用。\r\npublic static void dumpStack()|将当前线程的堆栈跟踪打印至标准错误流。\r\n\r\n', '1', 'post', 'publish', 'java', 'Java', '1', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('17', '【Android】程序设计 ——记账App项目android移动端的实现', null, '1520479609', '1520479753', '> 这是一个单纯的记账软件，目前的功能可以实现记账，显示总的支出、收入、结余，账单归类统计、用户信息管理功能，后续功能慢慢完善\r\n 源程序：https://github.com/zas023/CocoBill\r\n   后端地址：https://github.com/zas023/ssmBillBook\r\n\r\n    在我们生活中经常不知道钱花在什么地方，但是我们自己又不是很想写在记账本上进行管理,因为关于记账，我们每个人都有自己的需求，虽然市面上有许多优秀的记账app,所以对于自己来说，开发一个属于自己的软件来记账是个非常有趣的事情，但一直因为时间安排的原因未能实现。 \r\n    \r\n    所以趁着本学期程序实践的机会，顺便做一个项目，后台采用ssm框架，本人小白，如果有不足的地方，希望看到的大神给予指点建议，不胜感激！\r\n\r\n\r\n#### 一、需求分析\r\n> 简单分析一下自己的需求，对于衣食住行进行分类，然后记录每天的时间，记录下消费的原因，最为重要的就是金额了。总会做个账单统计，分析自己当前的支出和收入，离预算还有多少钱花费。\r\n\r\n####二、界面设计\r\n##### （一）主界面\r\n    采用ViewPger + TabLayout的模式，3个Fragment分别展示每月详单、每月按账单分类图表、每月按支付方式归类。（头部使用AppBarLayout以支持Toolbar的滑动）\r\n    其中部分借鉴于 https://github.com/wangjjj/TallyBook\r\n<p>\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231153404244?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231153440421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231153454220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n</p>\r\n\r\n##### （二） 添加、编辑账单界面\r\n        \r\n    向左画出账单编辑菜单，支撑账单分类、支付方式、时间日期、备注等信息的编辑。\r\n<p>\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231154106820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231154123907?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231154323925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n</p>\r\n\r\n##### （三） 菜单、设置、用户界面\r\n    其中主题选择放置于MainActivity中便于切换主题，头像是用户选择头像时直接裁剪成圆形并上传服务器。\r\n<p>\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231160022549?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231155513143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231155533317?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n</p>\r\n\r\n##### （四） 账单分类管理界面\r\n    ItemTouchHelper配合RecyclerView使用，支持长按滑动排序、左右滑动删除。（支付方式管理尚未完成，默认三种：现金、支付宝、微信）\r\n<p>\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231160332098?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n</p>\r\n\r\n##### （五）登陆注册界面\r\n    登陆到注册切换时将上下隐藏的两个输入框可见，便于切换回登录界面时保存用户输入信息。\r\n<p>\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231160841821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n<img width=\"32%\" src=\"http://img.blog.csdn.net/20171231161221446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" />\r\n</p>\r\n\r\n####三、程序设计\r\n\r\n    目前尚未想到本地数据库如何同服务器数据库同步，所以只支持在线操作。\r\n\r\n####四、代码实现\r\n    代码较多，就不直接贴了，欢迎左转链接。\r\n   源程序：https://github.com/zas023/CocoBill\r\n   后端地址：https://github.com/zas023/ssmBillBook\r\n\r\n到此基本功能就实现了，主要还是后端太弱，才刚刚接触，后续会完善更多功能，。\r\n\r\n#### Thanks to :\r\n1. butterknife: https://github.com/JakeWharton/butterknife\r\n2. glide: https://github.com/bumptech/glide\r\n3. okhttp: https://github.com/square/okhttp\r\n4. MPAndroidChart: https://github.com/PhilJay/MPAndroidChart\r\n5. Android-PickerView: https://github.com/Bigkoo/Android-PickerView\r\n6. AwesomeSplash: https://github.com/ViksaaSkool/AwesomeSplash\r\n', '1', 'post', 'publish', 'Java,Android', 'Android', '7', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('18', '斐讯k2路由器刷pandorabox认证哆点Drcom', null, '1520479881', '1520479881', '##斐讯k2路由器刷pandorabox认证哆点Drcom\r\n>哆点账号登陆只能让一个设备使用网络，使用wifi共享等代理软件又会被禁止，二到了老校区以后寝室的校园网wifi信号不好，对于我这种习惯了像在家一样随意上网的人真是真心不爽，所以就琢磨让哆点校园网免登陆又能多设备一起上网，正好前一段时间在京东上免费撸了一台斐讯k2，虽然成本不值几个钱但是很耐玩，刷机、加usb组nas服务器都可以。网上斐讯k2可刷的固件都不集成drcom认证，找了半天最多只有支持迅捷认证的 ，所以只有通过开源固件pandorabox，通过python程序在路由器上模拟drcom运行。网上教程大多杂乱，不全，并没有针对斐讯K2的详细教程。所以写个简单教程。\r\n\r\n首先必备工具：斐讯k2 一台，pc\r\n软件 ：Notepad++ 、python 、wireshark 、winscp\r\n\r\n###准备工作\r\n####**一、器材**\r\n说到网络器材，不一定要选斐讯K2的，像小米路由器、极路由器等等都是一样可以的。只是K2的成本为零，没错，不是广告。\r\n>京东免费斐讯：https://item.jd.com/2615810.html\r\n\r\n#### **二、安装 Python2.7**\r\n1.*双击 python-2.7.12.msi*\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170912183359448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n2.*选择安装路径*\r\n\r\n3.*选择Add python.exe to Path*\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170913190917834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n4.*安装完成后Win+X+C 打开命令提示符，输入 python 测试下能不能运行*\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170913191031301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**三、其他**\r\n    \r\n    接着安装Wireshark 和 Notepad++，这个没有特殊要求，一直点下一步就可以安装完成，就 不演示了，Putty 和WinSCP 不需要安装，直接双击看快捷方式就可以使用。\r\n    \r\n   ![这里写图片描述](http://img.blog.csdn.net/20170913191306630?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n###步骤\r\n####**一、斐讯K2刷不死breed web 恢复固件** \r\n\r\n1.用网线连接路由器的 LAN口和电脑网线接口\r\n![这里写图片描述](http://img.blog.csdn.net/20170913191504896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    以管理员身份运行路由器刷 breed Web 助手通用版 v2.8.exe，如果你购买的是 K1/K2，则选择斐讯 k1,k1s,k2 全自动方案，如果是小米路由器 mini，则选择小米路由器方案(需要开 启路由器 ssh 服务)，点击开始刷机，程序会自动运行，特别提醒，Breed 不支持小米路由器 3，不能用这个软件来刷，可能会变砖。\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170913191643400?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    刷机完成后，等待一段时间，拔掉路由器电源，按住复位按钮，插上电源，等待约 10 秒，在浏览器中输入 192.168.1.1，打开 Breed 控制台\r\n![这里写图片描述](http://img.blog.csdn.net/20170913191749172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n#### **二、再刷入pandorabox 固件**\r\n>选择合适的固件，我给了四个固件： 推荐使用 K2-PandoraBox-160922-adbyby.bin，预装有广告屏蔽插件Adbyby K2-PandoraBox-160922-no-usb.bin 没有预装Adbyby PandoraBox-ralink-mt7620-xiaomi-mini-squashfs-sysupgrade-r1055-20150615_5.5M.bin RT-AC54U-GPIO-1-PSG1208-64M_3.4.3.9-099.trx 华硕固件，非校园网用 若需要其他品牌路由器的潘多拉固件，可以访问 http://downloads.openwrt.org.cn/PandoraBox 在固件更新里选择合适的固件\r\n\r\n1.菜单选择固件更新\r\n![这里写图片描述](http://img.blog.csdn.net/20170913192159994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n2.等待刷机完成\r\n   \r\n    稍等后浏览器打开 192.168.1.1，用户名为 root，密码 admin。\r\n  \r\n![这里写图片描述](http://img.blog.csdn.net/20170913192013025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    点击网络→无线，修改你的 SSID 和无线密码，然后保存设置\r\n\r\n#### **三、配置Dr.COM脚本** \r\n>访问 https://github.com/drcoms/drcom-generic 下载适合你的 drcom版本（我提供的压缩包中已有下载）。看是否已经有适配你所在的学校，如果没有就接着抓包，需要提示的是，抓包的信息可以复用，只需要改下账号和密码，所以如果你已经 有了配置文件，就不需要安装桌面版的 Python2.7 和Wireshark，只需要修改你的登录脚本 账号和密码即可。\r\n\r\n1.首先打开客户端\r\n     \r\n    输入账户和密码，先不要登录\r\n![这里写图片描述](http://img.blog.csdn.net/20170913192719384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n2.打开Wireshark\r\n    \r\n  （1）  点击以太网，再点击 Start\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170913192946735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n  \r\n  （2） 登录客户端，短暂时间后点击左上角红色按钮 点击 File→Save As 保存为 dr.pcapng\r\n   ![这里写图片描述](http://img.blog.csdn.net/20170913193027878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n3.生成配置\r\n    \r\n    将dr.pcapng文件放入 *3-客户端抓包* 文件夹中，当前目录需要的三个文件，双击 Double_Click_to_Run.cmd，在当前目录会生成 config.txt 文件。\r\n![这里写图片描述](http://img.blog.csdn.net/20170913193245149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    生成的 config.txt 内容如下，每台电脑抓包生成的文件都不一样：\r\n   ![这里写图片描述](http://img.blog.csdn.net/20170913193412781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n#### **四、修改账户**\r\n1.使用Notepad++打开 Drcom.py\r\n    \r\n    修改#config 和%config_end 之间的配置信息为你 刚刚生成的，同时在 password=’’的引号里面输入你的密码。\r\n![这里写图片描述](http://img.blog.csdn.net/20170913193646694?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n2.然后注销Dr.com客户端，双击Drcom.py 运行\r\n    \r\n    出现如下信息说明登录成功，测 试看能否正常访问外网，如果可以，说明成功。\r\n![这里写图片描述](http://img.blog.csdn.net/20170913193805939?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n3.然后将Drcom.py 修改为没有后缀名的 drcom \r\n\r\n#### **五、使用winscp登陆路由器**\r\n1.配置文件完成后打开 WinSCP 登录\r\n  \r\n    新建站点，主机名为192.168.1.1，用户名root，密码admin。\r\n![这里写图片描述](http://img.blog.csdn.net/20170913194107931?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n2.将drcom文件放入\\usr\\bin目录下\r\n\r\n3.然后打开\\tmp 目录 \r\n    \r\n    把 2-路由器 python 安装包目录下的 2python-mini.ipk 拖进去，然后点击左上角 的安装\\tmp 目录的 ipk，等待接近 20s 时间，中间会提示无响应，不用理会\r\n![这里写图片描述](http://img.blog.csdn.net/20170913194424514?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    提示成功后，在终端中输入chmod +x /usr/bin/drcom，赋予权限\r\n  ![这里写图片描述](http://img.blog.csdn.net/20170913194607860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n4.将 *最终文件夹* 中 etc 文件夹下的rc.local复制到相应目录\r\n![这里写图片描述](http://img.blog.csdn.net/20170914163323377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n5.重启路由器，享受无线网络吧\r\n\r\n#### **六、注意**\r\n>重启路由器无效时可以打开 Putty软件\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170913195844422?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    依旧以root身份登陆，密码为admin\r\n  ![这里写图片描述](http://img.blog.csdn.net/20170913195926073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n    登陆成功后执行命令python /usr/bin/drcom即可。\r\n\r\n>注：也可以在WinSCP软件的终端执行此命令\r\n\r\n####**资源下载：**\r\nCSDN: http://download.csdn.net/download/adminpd/9977361', '1', 'post', 'publish', '', '其他', '1', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('19', '解决The JAVA_HOME environment variable is not defined correctly', null, '1520479960', '1520479960', '错误：The JAVA_HOME environment variable is not defined correctly\r\n![这里写图片描述](http://img.blog.csdn.net/20170909203619949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n无论是maven还是tomcat，总是提示:\r\n\r\n>NB: JAVA_HOME should point to a JDK not a JRE\r\n\r\n早先以为环境变量配置错误，但java和javac均能够执行，便一直没有找到原因。\r\n\r\n解决：\r\n>JAVA_HOME后一定不能加分号\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170909204042745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n由于win10对环境变量采用了新的编辑模式，所以这个分号很容易被自动添加上，而且容易被忽视掉！！！', '1', 'post', 'publish', '', '其他', '3', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('20', '【SSM】WEB项目中的中文乱码问题', null, '1520480013', '1520482734', '#### 1.解决HTML页面中的中文问题：\r\n>为了使HTML页面很好地支持中文，就必须在每个HTML页面的头部增加如下代码：\r\n\r\n```\r\n<META http-equiv=Content-Type content=\"text/html;charset=utf-8\">\r\n```\r\n\r\n#### 2.解决JSP页面中的中文问题\r\n>为了使JSP页面很好地支持中文，就必须在每个JSP页面的头部增加如下代码：\r\n\r\n```\r\n<%@ page contentType=\"text/html;charset=utf-8\" language=\"java\"%>\r\n```\r\n#### 3.解决Servlet响应结果的中文问题\r\n>为了使Servlet页面很好地支持中文，就必须在每个Servlet页面的头部增加如下代码：\r\n```\r\nresponse.setCharacterEncoding(\"utf-8\");\r\n```\r\n\r\n#### 4.解决页面数据传输的中文问题\r\n>为了使中文数据在各页面（组件）之间正常传递，最佳的方法就是采用编码过滤器来解决。在WEB.XML中配置一个编码过滤器，内容如下：\r\n\r\n```\r\n<!--定义编码过滤器-->\r\n\r\n    <filter>\r\n        <filter-name>encodingFilter</filter-name>\r\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n\r\n        <init-param>\r\n\r\n              <param-name>encoding</param-name>\r\n\r\n              <param-value>gb2312</param-value>\r\n        </init-param>  \r\n    </filter>\r\n\r\n    <filter-mapping>\r\n        <filter-name>encodingFilter</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n```\r\n\r\n#### 5.设置mysql编码为utf-8：\r\n> \r\n\r\n#### 6.设置tomcat编码：为解决以get方式提交的参数出现乱码，添加\r\n\r\n>修改tomcat下的conf/server.xml文件, 添加URIEncoding=\"UTF-8\"  \r\n\r\n```\r\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"   \r\n              connectionTimeout=\"20000\"   \r\n              redirectPort=\"8443\" URIEncoding=\"UTF-8\" />  \r\n```\r\n#### 7.解决@responsebody返回乱码问题：\r\n>在springmvc配置文件中添加\r\n\r\n\r\n```\r\n<mvc:annotation-driven>  \r\n        <!-- 消息转换器,解决responseBody返回中外乱码问题 -->  \r\n        <mvc:message-converters register-defaults=\"true\">  \r\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">  \r\n                <property name=\"supportedMediaTypes\" value=\"text/plain;charset=UTF-8\" />  \r\n            </bean>  \r\n        </mvc:message-converters>  \r\n    </mvc:annotation-driven>  \r\n\r\n```\r\n\r\n', '1', 'post', 'publish', 'SSM,Java,Spring', 'Java', '4', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('21', '【Git】解决本地多个ssh key问题', null, '1520480080', '1520482698', '### 解决本地多个ssh key问题\r\n>在设置github的时候，官方的说明文档要求备份当前的id_rsa，然后生成一份新的私钥用于github的登陆。如果真这样做，那么新的私钥是无法再继续登陆之前的机器的。\r\n\r\n这个问题我们可以通过在~/.ssh目录下增加config文件来解决。\r\n\r\n\r\n#### 1. 第一步是配置git用户名和邮箱\r\n\r\n        git config user.name \"用户名\"\r\n\r\n        git config user.email \"邮箱\"\r\n\r\n#### 2. 生成ssh key时同时指定保存的文件名\r\n```\r\nssh-keygen -t rsa -f ~/.ssh/id_rsa.work -C \"Key for Gitlab\"  \r\nssh-keygen -t rsa -f ~/.ssh/id_rsa.sohu -C \"Key for GitHub\"\r\n```\r\n>上面的id_rsa.sohu就是我们指定的文件名，这时~/.ssh目录下会多出id_rsa.sohu和id_rsa.sohu.pub两个文件，id_rsa.sohu.pub里保存的就是我们要使用的key。\r\n\r\n#### 3. 新增并配置config文件\r\n\r\n添加config文件\r\n\r\n如果config文件不存在，先添加；存在则直接修改\r\n\r\n    touch ~/.ssh/config\r\n\r\n在config文件里添加如下内容(User表示你的用户名)\r\n\r\n```\r\nHost *.cloudscape.sohu.com \r\n  \r\n    IdentityFile ~/.ssh/id_rsa.sohu\r\n    User lee  \r\n   \r\nHost github.com  \r\n    IdentityFile ~/.ssh/id_rsa.github  \r\n    User git  \r\n```\r\n\r\n>这样在登陆的时候，ssh会根据登陆不同的域来读取相应的私钥文件\r\n\r\n#### 4. 上传key到平台后台(省略)\r\n\r\n#### 5. 测试ssh key是否配置成功\r\n\r\n\r\n    ssh -T git@git.cloudscape.sohu.com\r\n\r\n成功的话会显示：\r\n\r\n    Welcome to GitLab, username!\r\n\r\n至此，本地便成功配置多个ssh key。日后如需添加，则安装上述配置生成key，并修改config文件即可。', '1', 'post', 'publish', 'Git', '其他', '2', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('22', '【Git】Git配置', null, '1520480107', '1520482655', '## 生成ssh key步骤\r\n\r\n\r\n#### 1. 配置git用户名和邮箱\r\n\r\n        git config user.name \"用户名\"\r\n\r\n        git config user.email \"邮箱\"\r\n\r\n>在config后加上 --global 即可全局设置用户名和邮箱。\r\n\r\n        git config --global user.name \"用户名\"\r\n\r\n        git config --global user.email \"邮箱\"\r\n\r\n#### 2. 生成ssh key\r\n输入：\r\n\r\n         ssh-keygen -t rsa -C \"邮箱\"\r\n\r\n然后根据提示连续回车即可在~/.ssh目录下得到id_rsa和id_rsa.pub两个文件，id_rsa.pub文件里存放的就是我们要使用的key。\r\n\r\n#### 3. 上传key到github\r\n使用命令：\r\n    clip < ~/.ssh/id_rsa.pub\r\n\r\n1. 复制key到剪贴板\r\n2. 登录github\r\n3. 点击右上方的Accounting settings图标\r\n4. 选择 SSH key\r\n5. 点击 Add SSH key\r\n![这里写图片描述](http://img.blog.csdn.net/20170831114237118?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n>也可以直接打开id_rsa.pub文件，复制其中内容，然后粘贴到github网站中，穿件SSH Key.\r\n\r\n#### 4. 测试是否配置成功\r\n\r\n    ssh -T git@github.com\r\n\r\n如果配置成功，则会显示：\r\nHi username! You\'ve successfully authenticated, but GitHub does not provide shell access.\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170831114107601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n>但有时候未必显示成功，但github访问也是没有问题的，还需要实际下载代码上传代码测试一下\r\n', '1', 'post', 'publish', 'Git', '其他', '4', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('23', 'vs2012打开提示加载失败（该项目需要用户输入）', null, '1520480240', '1520480240', '问题：打开昨天VS2012项目显示加载失败\r\n>用vs2012打开cocos2dx 2.2项目.sln 时提示加载失败：多试几次还是不行，提示该项目需要用户输入。\r\n\r\n    该项目需要用户输入, 如果需要更多信息，请重启或重新加载项目。\r\n\r\n解决方法：\r\n\r\n1. 到http://www.microsoft.com/en-us/download/details.aspx?id=36020 下载vs2012更新补丁文件并运行\r\n2. 更新成功，然后重启VS2012，打开上次项目，加载失败问题解决，这样就可以正常打开VS2012正常加载以前的工程了', '1', 'post', 'publish', 'VS', '其他', '2', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('24', 'Markdown基础语法整理', null, '1520480287', '1520480957', '### 关于Markdown\r\n\r\n>Markdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文\r\n>\r\n\r\n#### 背景\r\n    为何写此篇博文，因为写博文需经常用到Markdown语法，于是产生了对Markdown语法进行系统整理的想法。\r\n    \r\n### Markdown的优势\r\n - 简单标记符完成排版，所写即所见，让你专注于文字而不是排版\r\n - 纯文本，所以兼容性极强，可以用所有文本编辑器打开\r\n - 格式转换方便，Markdown文本可以轻松转换为 html、pdf等\r\n - Markdown 的标记语法有极好的可读性\r\n\r\n#### **1. 斜体和粗体**\r\n代码：\r\n```\r\n*斜体*或_斜体_\r\n**粗体**\r\n***加粗斜体***\r\n~~删除线~~\r\n\r\n```\r\n显示效果：\r\n\r\n- *斜体*或_斜体_\r\n- **粗体**\r\n- ***加粗斜体***\r\n- ~~删除线~~\r\n\r\n#### **2. 分级标题**\r\n第一种写法：\r\n```\r\n这是一个一级标题\r\n============================\r\n这是一个二级标题\r\n--------------------------------------------------\r\n```\r\n第二种写法：\r\n```\r\n# 一级标题\r\n## 二级标题\r\n### 三级标题\r\n#### 四级标题\r\n##### 五级标题\r\n###### 六级标题\r\n```\r\n    \r\n \r\n#### **3. 超链接**\r\nMarkdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。\r\n\r\n#### 3.1. 行内式\r\n\r\n语法说明：\r\n\r\n    []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。\r\n\r\n代码：\r\n\r\n```\r\n欢迎来到[CSDN](http://csdn.net)\r\n欢迎来到[CSDN](http://csdn.net \"CSDN\")\r\n这里写代码片\r\n```\r\n显示效果：\r\n\r\n- 欢迎来到[CSDN](http://csdn.net)\r\n- 欢迎来到[CSDN](http://csdn.net \"CSDN\")\r\n\r\n####3.2. 参考式\r\n\r\n>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。\r\n\r\n语法说明： \r\n      \r\n    参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。\r\n\r\n    如果链接文字本身可以做为链接标记，你也可以写成[链接文字][] \r\n    [链接文字]：链接地址的形式，见代码的最后一行。\r\n\r\n代码：\r\n```\r\n我经常去的几个网站[Baidu][1]、[CSDN][2]以及[自己的博客][3]\r\n[Leanote 笔记][2]是一个不错的[网站][]。\r\n[1]:http://www.baidu.com \"Google\"\r\n[2]:http://www.csdn.net\"Leanote\"\r\n[3]:http://http://blog.csdn.net/adminpd\"梵居闹市\"\r\n[网站]:http://http://blog.csdn.net/adminpd\r\n```\r\n显示效果：\r\n\r\n- 我经常去的几个网站[Baidu][1]、[CSDN][2]以及[自己的博客][3]\r\n- [Leanote 笔记][2]是一个不错的[网站][]。\r\n[1]:http://www.baidu.com \"Google\"\r\n[2]:http://www.csdn.net\"Leanote\"\r\n[3]:http://http://blog.csdn.net/adminpd\"梵居闹市\"\r\n[网站]:http://http://blog.csdn.net/adminpd\r\n\r\n#### 3.3. 自动链接\r\n\r\n语法说明： \r\n    \r\n    Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用<>包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\r\n\r\n代码：\r\n```\r\n<http://example.com/>\r\n<address@example.com>\r\n```\r\n显示效果：\r\n\r\n- <http://example.com/>\r\n- <address@example.com>\r\n\r\n#### **4. 锚点**\r\n>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。\r\n\r\n注意： \r\n    \r\n    1. Markdown Extra 只支持在标题后插入锚点，其它地方无效。 \r\n    2. Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。\r\n\r\n语法描述： \r\n    \r\n    在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。\r\n\r\n代码：\r\n```\r\n## 0. 目录{#index}\r\n跳转到[目录](#index)\r\n```\r\n显示效果：\r\n\r\n- 跳转到[目录](#index)\r\n\r\n#### **5. 列表**\r\n#### 5.1. 无序列表\r\n\r\n>使用 *，+，- 表示无序列表。\r\n\r\n代码：\r\n```\r\n- 无序列表项 一\r\n- 无序列表项 二\r\n- 无序列表项 三\r\n```\r\n\r\n显示效果：\r\n\r\n- 无序列表项 一\r\n- 无序列表项 二\r\n- 无序列表项 三\r\n#### 5.2. 有序列表\r\n\r\n>有序列表则使用数字接着一个英文句点。\r\n\r\n代码：\r\n\r\n```\r\n1. 有序列表项 一\r\n2. 有序列表项 二\r\n3. 有序列表项 三\r\n```\r\n显示效果：\r\n\r\n1. 有序列表项 一\r\n2. 有序列表项 二\r\n3. 有序列表项 三\r\n#### 5.3. 定义型列表\r\n\r\n语法说明：\r\n\r\n    定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\r\n\r\n代码：\r\n```\r\nMarkdown\r\n:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）\r\n代码块 2\r\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\r\n        代码块（左侧有八个不可见的空格）\r\n```\r\n\r\n显示效果：\r\n\r\nMarkdown\r\n:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）\r\n代码块 2\r\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\r\n        代码块（左侧有八个不可见的空格）\r\n\r\n代码块（左侧有八个不可见的空格）\r\n\r\n#### 5.3. 列表缩进\r\n\r\n语法说明：\r\n\r\n>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\r\n\r\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：\r\n\r\n    轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 \r\n    那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 \r\n    软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\r\n    那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 \r\n    寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 \r\n    但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ \r\n    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\r\n    \r\n但是如果你懒，那也行： \r\n\r\n代码：\r\n```\r\n*   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\r\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 \r\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ \r\n*   那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 \r\n寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 \r\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ \r\n悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\r\n```\r\n显示效果：\r\n\r\n轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 \r\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 \r\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\r\n那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 \r\n寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 \r\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ \r\n悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\r\n####5.4. 包含段落的列表\r\n\r\n语法说明：\r\n\r\n>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：\r\n\r\n    轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 \r\n    那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 \r\n    软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\r\n\r\n    那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 \r\n    寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 \r\n    但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！\r\n\r\n    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\r\n\r\n如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\r\n\r\n代码：\r\n```\r\n*   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\r\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 \r\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\r\n*     那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 \r\n寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 \r\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ \r\n*    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\r\n```\r\n显示效果：\r\n\r\n*   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\r\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 \r\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\r\n*      那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 \r\n寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 \r\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ \r\n*    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\r\n\r\n#### 5.5. 包含引用的列表\r\n\r\n语法说明：\r\n\r\n    如果要在列表项目内放进引用，那 > 就需要缩进：\r\n\r\n代码：\r\n```\r\n*   阅读的方法:\r\n    > 打开书本。\r\n    > 打开电灯。\r\n```\r\n显示效果：\r\n\r\n*   阅读的方法:\r\n    > 打开书本。\r\n    > 打开电灯。\r\n####5.6. 包含代码区块的引用\r\n\r\n语法说明： \r\n    \r\n    如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：\r\n\r\n*    一列表项包含一个列表区块：\r\n\r\n        <代码写在这>\r\n\r\n#### 5.7. 一个特殊情况\r\n\r\n在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：\r\n```\r\n1986. What a great season.\r\n```\r\n会显示成：\r\n\r\n1986. What a great season.\r\n\r\n换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：\r\n```\r\n1986\\. What a great season.\r\n```\r\n会显示成：\r\n\r\n1986\\. What a great season.\r\n\r\n#### **6. 引用**\r\n语法说明：\r\n\r\n    引用需要在被引用的文本前加上>符号。\r\n\r\n代码：\r\n```\r\n> 这是一个有两段文字的引用,\r\n> 无意义的占行文字1.\r\n> 无意义的占行文字2.\r\n> \r\n> 无意义的占行文字3.\r\n> 无意义的占行文字4.\r\n```\r\n显示效果：\r\n\r\n> 这是一个有两段文字的引用,\r\n> 无意义的占行文字1.\r\n> 无意义的占行文字2.\r\n> \r\n> 无意义的占行文字3.\r\n> 无意义的占行文字4.\r\n\r\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 > ：\r\n\r\n代码：\r\n```\r\n> 这是一个有两段文字的引用,\r\n无意义的占行文字1.\r\n无意义的占行文字2.\r\n> 无意义的占行文字3.\r\n无意义的占行文字4.\r\n```\r\n显示效果：\r\n\r\n> 这是一个有两段文字的引用,\r\n无意义的占行文字1.\r\n无意义的占行文字2.\r\n> 无意义的占行文字3.\r\n无意义的占行文字4.\r\n#### 6.1. 引用的多层嵌套\r\n\r\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 > ：\r\n\r\n代码：\r\n```\r\n>>> 请问 Markdwon 怎么用？ - A\r\n>> 自己看教程！ - B\r\n> 教程在哪？ - A\r\n```\r\n显示效果：\r\n\r\n>>> 请问 Markdwon 怎么用？ - A\r\n>> 自己看教程！ - B\r\n> 教程在哪？ - A\r\n#### 6.2. 引用其它要素\r\n\r\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\r\n\r\n代码：\r\n```\r\n> 1.   这是第一行列表项。\r\n> 2.   这是第二行列表项。\r\n> \r\n> 给出一些例子代码：\r\n> \r\n>     return shell_exec(\"echo $input | $markdown_script\");\r\n```\r\n显示效果：\r\n\r\n> 1.   这是第一行列表项。\r\n> 2.   这是第二行列表项。\r\n> \r\n> 给出一些例子代码：\r\n> \r\n>     return shell_exec(\"echo $input | $markdown_script\");\r\n\r\n#### **7. 插入图像**\r\n>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。\r\n\r\n>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。\r\n####7.1. 行内式\r\n\r\n语法说明：\r\n    \r\n    ![图片Alt](图片地址 “图片Title”)\r\n\r\n代码：\r\n```\r\nmarkdown 语法： \r\n![markdown 语法](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1503249365272&di=4365c9b433a96044bb53b28c674ffdf3&imgtype=0&src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg \"markdown 语法\")\r\n```\r\n显示效果：\r\n\r\nmarkdown 语法： \r\n![markdown 语法](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1503249365272&di=4365c9b433a96044bb53b28c674ffdf3&imgtype=0&src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg \"markdown 语法\")\r\n\r\n#### 7.2. 参考式\r\n\r\n语法说明：\r\n\r\n    在文档要插入图片的地方写![图片Alt][标记]\r\n\r\n    在文档的最后写上[标记]:图片地址 “Title”\r\n\r\n代码：\r\n```\r\nmarkdown 语法： \r\n![markdown 语法][markdown ]\r\n[markdown ]:https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1503249365272&di=4365c9b433a96044bb53b28c674ffdf3&imgtype=0&src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg \"markdown 语法\"\r\n```\r\n显示效果：\r\nmarkdown 语法： \r\n![markdown 语法][markdown ]\r\n[markdown ]:https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1503249365272&di=4365c9b433a96044bb53b28c674ffdf3&imgtype=0&src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg \"markdown 语法\"\r\n\r\n#### **8. 内容目录**\r\n>在段落中填写 [TOC] 以显示全文内容的目录结构。\r\n\r\n>效果参见最上方的目录\r\n\r\n#### **9. 注脚**\r\n语法说明：\r\n\r\n    在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。\r\n\r\n    \r\n    注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。\r\n\r\n代码：\r\n```\r\n使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。\r\n\r\n[^1]:Markdown是一种纯文本标记语言\r\n\r\n[^2]:HyperText Markup Language 超文本标记语言\r\n\r\n[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文\r\n```\r\n显示效果：\r\n\r\n使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。\r\n\r\n[^1]:Markdown是一种纯文本标记语言\r\n\r\n[^2]:HyperText Markup Language 超文本标记语言\r\n\r\n[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文\r\n\r\n\r\n    注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。\r\n\r\n#### **10. LaTeX 公式**\r\n#### 10.1. $ 表示行内公式：\r\n\r\n代码：\r\n```\r\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\r\n```\r\n显示效果：\r\n\r\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\r\n\r\n#### 10.2 $$ 表示整行公式：\r\n\r\n代码：\r\n```\r\n$$\\sum_{i=1}^n a_i=0$$\r\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\r\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$\r\n```\r\n显示效果：\r\n$$\\sum_{i=1}^n a_i=0$$\r\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\r\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$\r\n\r\n\r\n#### **11. 流程图**\r\n代码：\r\n```\r\n```flow\r\nst=>start: Start\r\nop=>operation: Your Operation\r\ncond=>condition: Yes or No?\r\ne=>end\r\n\r\nst->op->cond\r\ncond(yes)->e\r\ncond(no)->op\r\n ```\r\n\r\n```\r\n显示效果：\r\n\r\n```flow\r\nst=>start: Start\r\nop=>operation: Your Operation\r\ncond=>condition: Yes or No?\r\ne=>end\r\n\r\nst->op->cond\r\ncond(yes)->e\r\ncond(no)->op\r\n```\r\n\r\n#### **12 .表格**\r\n语法说明：\r\n\r\n    不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。\r\n    列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。\r\n    第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。\r\n代码：\r\n\r\n简单方式写表格：\r\n```\r\n学号|姓名|分数\r\n-|-|-\r\n小明|男|75\r\n小红|女|79\r\n小陆|男|92\r\n```\r\n原生方式写表格：\r\n```\r\n|学号|姓名|分数|\r\n|-|-|-|\r\n|小明|男|75|\r\n|小红|女|79|\r\n|小陆|男|92|\r\n```\r\n为表格第二列指定方向：\r\n```\r\n产品|价格\r\n-|-:\r\nLeanote 高级账号|60元/年\r\nLeanote 超级账号|120元/年\r\n```\r\n显示效果： \r\n\r\n    简单方式写表格：\r\n\r\n学号|姓名|分数\r\n-|-|-\r\n小明|男|75\r\n小红|女|79\r\n小陆|男|92\r\n     \r\n \r\n    原生方式写表格：\r\n\r\n|学号|姓名|分数|\r\n|-|-|-|\r\n|小明|男|75|\r\n|小红|女|79|\r\n|小陆|男|92|\r\n\r\n\r\n    为表格第二列指定方向：\r\n\r\n产品|价格\r\n-|-:\r\nLeanote 高级账号|60元/年\r\nLeanote 超级账号|120元/年\r\n#### **13. 分隔线**\r\n>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\r\n\r\n代码：\r\n```\r\n* * *\r\n***\r\n*****\r\n- - -\r\n---------------------------------------\r\n```\r\n显示效果都一样：\r\n\r\n#### **14. 代码**\r\n对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。\r\n\r\n语法说明：\r\n\r\n    插入行内代码，即插入一个单词或者一句代码的情况，使用`code`这样的形式插入。\r\n    \r\n    插入多行代码，可以使用缩进或者“` code “`,具体看示例。\r\n    \r\n    注意： 缩进式插入前方必须有空行\r\n\r\n#### 8.1. 行内式\r\n\r\n代码：\r\n```\r\nC语言里的函数 `scanf()` 怎么使用？\r\n```\r\n显示效果：\r\n\r\nC语言里的函数 `scanf()` 怎么使用？\r\n\r\n#### 8.2. 缩进式多行代码\r\n\r\n>缩进 4 个空格或是 1 个制表符\r\n\r\n>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\r\n\r\n代码：\r\n```\r\n ```\r\n    #include <stdio.h>\r\n    int main(void)\r\n    {\r\n        printf(\"Hello world\\n\");\r\n    }\r\n ```\r\n```\r\n显示效果：\r\n\r\n```\r\n    #include <stdio.h>\r\n    int main(void)\r\n    {\r\n        printf(\"Hello world\\n\");\r\n    }\r\n```\r\n####8.3. 用六个`包裹多行代码\r\n\r\n代码：\r\n```\r\n ```\r\n#include <stdio.h>\r\nint main(void)\r\n{\r\n    printf(\"Hello world\\n\");\r\n}\r\n ```\r\n```\r\n显示效果：\r\n\r\n```\r\n#include <stdio.h>\r\nint main(void)\r\n{\r\n    printf(\"Hello world\\n\");\r\n}\r\n```\r\n\r\n\r\n#### 8.4. HTML 原始码\r\n\r\n\r\n>在代码区块里面， & 、 < 和 > 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：\r\n\r\n代码：\r\n\r\n第一个例子：\r\n```\r\n<div class=\"footer\">\r\n   :copyright: 2004 Foo Corporation\r\n</div>\r\n```\r\n第二个例子：\r\n```\r\n<table>\r\n    <tr>\r\n        <th rowspan=\"2\">值班人员</th>\r\n        <th>星期一</th>\r\n        <th>星期二</th>\r\n        <th>星期三</th>\r\n    </tr>\r\n    <tr>\r\n        <td>李强</td>\r\n        <td>张明</td>\r\n        <td>王平</td>\r\n    </tr>\r\n</table>\r\n```\r\n\r\n\r\n显示效果:\r\n\r\n\r\n    第一个例子：\r\n\r\n\r\n<div class=\"footer\">\r\n   :copyright: 2004 Foo Corporation\r\n</div>\r\n\r\n    第二个例子：\r\n\r\n<table>\r\n    <tr>\r\n        <th rowspan=\"2\">值班人员</th>\r\n        <th>星期一</th>\r\n        <th>星期二</th>\r\n        <th>星期三</th>\r\n    </tr>\r\n    <tr>\r\n        <td>李强</td>\r\n        <td>张明</td>\r\n        <td>王平</td>\r\n    </tr>\r\n</table>', '1', 'post', 'publish', 'Markdown', '其他', '3', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('25', '【C++】C++大数的运算', null, '1520480330', '1520480802', '### 一、实验项目内容\r\n####(HugeInteger Class) Create a class HugeInteger that uses a 40-element array of digits to store integers as large as 40 digits each.\r\n\r\n      1.Provide member functions input, output, add and subtract.\r\n      2.For comparing HugeInteger objects, provide functions isEqualTo, isNotEqualTo, isGreaterThan, isLessThan, isGreaterThanOrEqualTo and isLessThanOrEqualTo — each of these is a “predicate” function that simply returns true if the relationship holds between the two HugeIntegers and returns false if the relationship does not hold.\r\n      3.Also, provide a predicate function isZero.\r\n      4.If you feel ambitious, provide member functions multiply, divide and modulus.\r\n      \r\n### 二、实验过程或算法\r\n **HugeInteger.h:**\r\n \r\n```\r\n#ifndef CIRCLE_H\r\n#define CIRCLE_H\r\n#include <algorithm>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nclass HugeInteger{\r\n	private:\r\n	char* HugeInteger1;                                  //声明私有成员HugeInteger1\r\n	char* HugeInteger2;                                  //声明私有成员HugeInteger2\r\n//    char* AddNumber;\r\n//    char* SubNumber;\r\n    int compareFlag;                                     //判断标志\r\n    int isEqual=0;                                       //HugeInteger1=HugeInteger2\r\n    int isGreater=1;                                     //HugeInteger1>HugeInteger2\r\n    int isLess=-1;                                       //HugeInteger1<HugeInteger2\r\n\r\npublic:\r\n    HugeInteger();                                       //构造函数1\r\n    HugeInteger( char* HugeInteger1, char* HugeInteger2);//构造函数2\r\n\r\n	char* getAddNumber();                                //加法运算\r\n	char* getSubNumber();                                //减法运算\r\n\r\n	char* getHugeInteger1();                             //getter and setter\r\n	void setHugeInteger1(char* hugeInteger1);\r\n	char* getHugeInteger2();\r\n	void setHugeInteger2(char* hugeInteger2);\r\n\r\n	bool isEqualTo();                                     //compare\r\n	int isNotEqualTo();                                  //return true or false\r\n	int isGreaterThan();\r\n	int isLessThan();\r\n	int isGreaterThanOrEqualTo();\r\n	int isLessThanOrEqualTo();\r\n\r\n	void compare();                                      //比较两数大小的函数\r\n\r\n};\r\n\r\n#endif\r\n\r\n```\r\n **HugeInteger.cpp:**\r\n\r\n```\r\n#include \"HugeInteger.h\"\r\n\r\nHugeInteger::HugeInteger(){\r\n	this->HugeInteger1=\"88888888888888888888888888888888888888888888888888888888888888888888888888\";\r\n	this->HugeInteger2=\"66666666666666666666666666666666666666666666666666666666666666666666666666\";\r\n\r\n	compare();\r\n}\r\n\r\nHugeInteger:: HugeInteger( char* HugeInteger1, char* HugeInteger2){\r\n	this->HugeInteger1=HugeInteger1;\r\n	this->HugeInteger2=HugeInteger2;\r\n\r\n	compare();\r\n}\r\n\r\nchar* HugeInteger::getHugeInteger1(){\r\n	return HugeInteger1;\r\n}\r\nchar* HugeInteger::getHugeInteger2(){\r\n	return HugeInteger2;\r\n}\r\n\r\nvoid HugeInteger::setHugeInteger1(char* hugeInteger1){\r\n	this->HugeInteger1=HugeInteger1;\r\n}\r\nvoid HugeInteger::setHugeInteger2(char* hugeInteger2){\r\n	this->HugeInteger1=HugeInteger2;\r\n}\r\n\r\nvoid HugeInteger::compare(){\r\n	int lHugeInteger1=strlen(HugeInteger1), lHugeInteger2=strlen(HugeInteger2);\r\n	if(lHugeInteger1>lHugeInteger2){                       //HugeInteger1的位数大于HugeInteger2，则HugeInteger1大\r\n		compareFlag=isGreater;\r\n	}\r\n	else if(lHugeInteger1<lHugeInteger2){                  //HugeInteger1的位数小于HugeInteger2,则HugeInteger1小\r\n		compareFlag=isLess;\r\n	}\r\n	else{                                                  //位数相等\r\n		char* pHugeInteger1 = HugeInteger1;\r\n		char* pHugeInteger2 = HugeInteger2;\r\n\r\n		for(int c=0;c<lHugeInteger1;c++){                  //依次比较每一位数的大小\r\n			if((*pHugeInteger1)>(*pHugeInteger2)){         //不等，则比较大小\r\n				compareFlag=isGreater;\r\n				break;\r\n			}\r\n			else if((*pHugeInteger1)<(*pHugeInteger2)){\r\n				compareFlag=isLess;\r\n				break;\r\n			}\r\n			else{                                          //相等继续\r\n				continue;\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nchar* HugeInteger::getAddNumber() {\r\n	int maxlen = max(strlen(HugeInteger1), strlen(HugeInteger2));\r\n	//多两个字符，一个是结束符\'/0\'，另一个保存当两个数最高位相加后有进位的情况\r\n	char* p = new char[maxlen + 2];\r\n	//结束符\r\n	*(p + maxlen + 1) = \'\\0\';\r\n	//声明两个指针分别指向HugeInteger1和HugeInteger2的末尾，不含结束符\r\n	char* pHugeInteger1 = HugeInteger1 + strlen(HugeInteger1) - 1;\r\n	char* pHugeInteger2 = HugeInteger2 + strlen(HugeInteger2) - 1;\r\n	int m = 0;\r\n	int n = 0;\r\n	//进位\r\n	int c = 0;\r\n	for (int i = maxlen; i > 0; i--) {\r\n		m = n = 0;\r\n		//因为当pHugeInteger1到达第一个字符时，即pHugeInteger1=a时，也要进行计算，所以这里用(pHugeInteger1-1)来判断\r\n		//\'0\'的Asic是48，减去48转成数字\r\n		if ((pHugeInteger1 + 1) != HugeInteger1) {\r\n			m = *pHugeInteger1 - 48;\r\n			pHugeInteger1--;\r\n		}\r\n		if ((pHugeInteger2 + 1) != HugeInteger2) {\r\n			n = *pHugeInteger2 - 48;\r\n			pHugeInteger2--;\r\n		}\r\n		//为p指针的第i个字符赋值\r\n		*(p + i) = (m + n + c) % 10 + 48;\r\n		//取得进位\r\n		c = (m + n + c) / 10;\r\n	}\r\n	*p = 48 + c;\r\n\r\n	if(*p==\'0\'){                        //如果结果的第一位是‘0’，表示没有进位\r\n		return p+1;                     //返回第二位的指针，以去除第一位多余的0\r\n	}\r\n	return p;\r\n}\r\nchar* HugeInteger::getSubNumber(){\r\n\r\n	int isNegative=0;                   //定义结果是否为负数的标志，初始为0,不是负数\r\n\r\n	if(compareFlag==isLess){            //如果HugeInteger1小于HugeInteger2,置换两数\r\n		char* temp=HugeInteger1;\r\n		HugeInteger1=HugeInteger2;\r\n		HugeInteger2=temp;\r\n\r\n		isNegative=1;                   //结果为负\r\n	}\r\n\r\n	int maxlen = max(strlen(HugeInteger1), strlen(HugeInteger2));\r\n	//应为HugeInteger1始终大于HugeInteger2,不考虑被减数最高位不够减的情况\r\n	char* p = new char[maxlen + 1];\r\n	//最后一位是结束符\r\n	*(p + maxlen) = \'\\0\';\r\n	//声明两个指针分别指向HugeInteger1和HugeInteger2的末尾，不包含结束符\r\n	char* pHugeInteger1 = HugeInteger1 + strlen(HugeInteger1) - 1;\r\n	char* pHugeInteger2 = HugeInteger2 + strlen(HugeInteger2) - 1;\r\n	int m = 0;\r\n	int n = 0;\r\n	//借位位\r\n	int c = 0;\r\n	for (int i = maxlen - 1; i >=0; i--) {\r\n		m = n = 0;\r\n		//\'0\'的Asic是48，减去48转成数字\r\n		if ((pHugeInteger1 + 1) != HugeInteger1) {\r\n			m = *pHugeInteger1 - 48;\r\n			pHugeInteger1--;\r\n		}\r\n		if ((pHugeInteger2 + 1) != HugeInteger2) {\r\n			n = *pHugeInteger2 - 48;\r\n			pHugeInteger2--;\r\n		}\r\n		//不够减，要借位\r\n		if (m < n) {\r\n			//为p指针的第i个字符赋值\r\n			*(p + i) = 10 + m - n - c + 48;\r\n			c = 1;\r\n		} else {\r\n			//虽然够减，但是如果再算是借走的一位，那么就小于0了\r\n			if (m - n - c < 0)\r\n				*(p + i) = 10 + m - n - c + 48;\r\n			else {\r\n				*(p + i) = m - n - c + 48;\r\n				c = 0;\r\n			}\r\n		}\r\n	}\r\n	if (isNegative == 1) {\r\n		if (*p == \'0\') {                        //如果结果的第一位是‘0’，表示没有进位\r\n			char* temp = new char[maxlen];\r\n			temp = p + 1;                            //返回第二位的指针，以去除第一位多余的0\r\n			char* newp = new char[maxlen + 1];\r\n			*newp = \'-\';                             //首地址带符号‘-’\r\n			for (int i = 0; i < maxlen; i++) {\r\n				*(newp + 1 + i) = *(temp+i);\r\n			}\r\n			return newp;                          //返回带符号的新字符串\r\n		}\r\n		else {\r\n			char* temp2 = new char[maxlen+1];\r\n			temp2 = p ;\r\n			char* newp2 = new char[maxlen +2];\r\n			*newp2 = \'-\';                             //首地址带符号‘-’\r\n			for (int i = 0; i < maxlen+1; i++) {\r\n				*(newp2 + 1 + i) = *(temp2+i);\r\n			}\r\n			return newp2;                          //返回带符号的新字符串\r\n		}\r\n	}\r\n	else {\r\n		if (*p == \'0\') {                        //如果结果的第一位是‘0’，表示没有进位\r\n			return p+1;                     //返回第二位的指针，以去除第一位多余的0\r\n		}\r\n		return p;\r\n	}\r\n}\r\n\r\nint HugeInteger::isGreaterThan(){\r\n	if(compareFlag==isGreater){\r\n		return true;\r\n	}\r\n	else{\r\n		return false;\r\n	}\r\n}\r\nint HugeInteger::isLessThan(){\r\n	if(compareFlag==isLess){\r\n		return true;\r\n	}\r\n	else{\r\n		return false;\r\n	}\r\n}\r\nbool HugeInteger::isEqualTo(){\r\n	if(compareFlag==isEqual){\r\n		return true;\r\n	}\r\n	else{\r\n		return false;\r\n	}\r\n}\r\nint HugeInteger::isNotEqualTo(){\r\n	if(compareFlag==isEqual){\r\n		return false;\r\n	}\r\n	else{\r\n		return true;\r\n	}\r\n}\r\nint HugeInteger::isGreaterThanOrEqualTo(){\r\n	if(compareFlag==isLess){\r\n		return false;\r\n	}\r\n	return true;\r\n}\r\nint HugeInteger::isLessThanOrEqualTo(){\r\n	if(compareFlag==isGreater){\r\n		return false;\r\n	}\r\n	return true;\r\n}\r\n\r\n```\r\n\r\n**测试类：**\r\n\r\n```\r\n\r\n#include <iostream>\r\n#include \"HugeInteger.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n	string hugeInt1,hugeInt2;                      //声明两个string来存储HugeIntegers\r\n\r\n	cout<<\"please enter the first hugeInteger :\";   //输入HugeIntegers\r\n	cin>>hugeInt1;\r\n	cout<<\"please enter the second hugeInteger:\";\r\n	cin>>hugeInt2;\r\n\r\n	const char* a =hugeInt1.c_str();                //sting转换成char*\r\n	const char* b =hugeInt2.c_str();\r\n/*\r\n	HugeInteger hugeInteger1;                       //HugeInteger默认构造函数\r\n	cout << hugeInteger1.getAddNumber() << endl;    //\r\n	cout << hugeInteger1.getSubNumber() << endl;\r\n*/\r\n\r\n	HugeInteger hugeInteger((char*)a,(char*)b);    //声明一个hugeInteger的object\r\n	                                               //输出原始数据\r\n	cout <<\"The first hugeInteger is :\"<<hugeInteger.getHugeInteger1() << endl;\r\n	cout <<\"The second hugeInteger is:\"<<hugeInteger.getHugeInteger2() << endl;\r\n\r\n	cout <<\"\\n\";                                    //输出相加相减结果\r\n	cout <<\"The AddNumber is:\"<<hugeInteger.getAddNumber() << endl;\r\n	cout <<\"The SubNumber is:\"<<hugeInteger.getSubNumber() << endl;\r\n\r\n	cout <<\"\\n\";\r\n	cout << \"isEqualTo:\"<<hugeInteger.isEqualTo()<< endl;      //输出比较大小的结果\r\n	cout << \"isGreaterThan:\"<<hugeInteger.isGreaterThan()<< endl;\r\n	cout << \"isGreaterThanOrEqualTo:\"<<hugeInteger.isGreaterThanOrEqualTo()<< endl;\r\n	cout <<\"isLessThan:\"<< hugeInteger.isLessThan()<< endl;\r\n	cout << \"isLessThanOrEqualTo:\"<<hugeInteger.isLessThanOrEqualTo()<< endl;\r\n	cout << \"isNotEqualTo:\"<<hugeInteger.isNotEqualTo()<< endl;\r\n\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n三、实验结果和截图', '1', 'post', 'publish', 'C++', 'C/C++', '1', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('26', '【C++】C++大数之运算符重载', null, '1520480357', '1520480754', '### 一、实验项目内容\r\n####Modify the “HugeInteger” Class. The new class should also provide the following overloaded operator capabilities:\r\n    . Overload the addition operator (+), the subtraction operator (-), the multiplication operator (*) and the division operator (/).\r\n    . Overload output operator (<<).\r\n    . Overload all the relational and equality operators.\r\nYou can use the following code to test your class design.\r\n\r\n```\r\n// HugeInt test program.\r\n#include <iostream>\r\n#include \"Hugeint.h\"\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n   HugeInt n1( 7654321 );\r\n   HugeInt n2( 7891234 );\r\n   HugeInt n3( \"99999999999999999999999999999\" );\r\n   HugeInt n4( \"1\" );\r\n   HugeInt n5;\r\n \r\n   cout << \"n1 is \" << n1 << \"\\nn2 is \" << n2\r\n      << \"\\nn3 is \" << n3 << \"\\nn4 is \" << n4\r\n      << \"\\nn5 is \" << n5 << \"\\n\\n\";\r\n \r\n   n5 = n1 + n2;\r\n   cout << n1 << \" + \" << n2 << \" = \" << n5 << \"\\n\\n\";\r\n \r\n   cout << n3 << \" + \" << n4 << \"\\n= \" << ( n3 + n4 ) << \"\\n\\n\";\r\n \r\n   n5 = n1 + 9;\r\n   cout << n1 << \" + \" << 9 << \" = \" << n5 << \"\\n\\n\";\r\n \r\n   n5 = n2 + \"10000\";\r\n   cout << n2 << \" + \" << \"10000\" << \" = \" << n5 << endl;\r\n}\r\n```\r\n### 二、实验过程或算法\r\n**HugeInteger.h：**\r\n```\r\n#ifndef HUGEINTER_H\r\n#define HUGEINTER_H\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nclass HugeInteger{\r\n\r\nprivate:\r\n	string hugeInteger;                                  //声明私有成员hugeInteger\r\n\r\npublic:\r\n\r\n    HugeInteger();                                       //default构造函数\r\n    HugeInteger( string HugeInteger1);                    //构造函数1\r\n    HugeInteger( int HugeInteger1);                       //构造函数2\r\n    string getHugeInteger();                              //getting\r\n    void setHugeInteger(const string& hugeInteger);       //setting\r\n\r\n    //重载<<\r\n	friend ostream& operator<<(ostream& output, const HugeInteger& aHugeInter) ;\r\n\r\n	//重载+\r\n	friend HugeInteger operator +(const HugeInteger& aHugeInteger, const HugeInteger& bHugeInteger);\r\n	friend HugeInteger operator +(const HugeInteger& aHugeInteger, const string s);\r\n	friend HugeInteger operator +(const HugeInteger& aHugeInteger, const int i);\r\n	//重载-\r\n	friend HugeInteger operator -(const HugeInteger& aHugeInteger, const HugeInteger& bHugeInteger);\r\n	friend HugeInteger operator -(const HugeInteger& aHugeInteger, const string s);\r\n	friend HugeInteger operator -(const HugeInteger& aHugeInteger, const int i);\r\n\r\n	//重载*\r\n	friend HugeInteger operator *(const HugeInteger& aHugeInteger,const HugeInteger& bHugeInteger);\r\n	friend HugeInteger operator *(const HugeInteger& aHugeInteger,const string s);\r\n	friend HugeInteger operator *(const HugeInteger& aHugeInteger, const int i);\r\n\r\n	//重载/\r\n	friend HugeInteger operator /(const HugeInteger& aHugeInteger,\r\n			const HugeInteger& bHugeInteger);\r\n	friend HugeInteger operator /(const HugeInteger& aHugeInteger,\r\n			const string s);\r\n	friend HugeInteger operator /(const HugeInteger& aHugeInteger, const int i);\r\n\r\n};\r\n#endif\r\n```\r\n\r\n**HugeInteger.cpp:**\r\n```\r\n#include \"HugeInteger.h\"\r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <algorithm>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nHugeInteger::HugeInteger(){\r\n	this->hugeInteger=\"null\";\r\n}\r\n\r\nHugeInteger:: HugeInteger( string HugeInteger1){\r\n	this->hugeInteger=HugeInteger1;\r\n}\r\nHugeInteger:: HugeInteger( int HugeInteger1){\r\n\r\n	char t[256];\r\n	sprintf(t, \"%d\", HugeInteger1);\r\n	this->hugeInteger=t;\r\n}\r\n\r\nstring HugeInteger::getHugeInteger() {\r\n		return hugeInteger;\r\n	}\r\n\r\nvoid HugeInteger:: setHugeInteger(const string& hugeInteger) {\r\n		this->hugeInteger = hugeInteger;\r\n	}\r\n//加法运算\r\nchar* getAddNumber(char* HugeInteger1,char* HugeInteger2) {\r\n	int maxlen = max(strlen(HugeInteger1), strlen(HugeInteger2));\r\n	//多两个字符，一个是结束符\'/0\'，另一个保存当两个数最高位相加后有进位的情况\r\n	char* p = new char[maxlen + 2];\r\n	//结束符\r\n	*(p + maxlen + 1) = \'\\0\';\r\n	//声明两个指针分别指向HugeInteger1和HugeInteger2的末尾，不含结束符\r\n	char* pHugeInteger1 = HugeInteger1 + strlen(HugeInteger1) - 1;\r\n	char* pHugeInteger2 = HugeInteger2 + strlen(HugeInteger2) - 1;\r\n	int m = 0;\r\n	int n = 0;\r\n	//进位\r\n	int c = 0;\r\n	for (int i = maxlen; i > 0; i--) {\r\n		m = n = 0;\r\n		//因为当pHugeInteger1到达第一个字符时，即pHugeInteger1=a时，也要进行计算，所以这里用(pHugeInteger1-1)来判断\r\n		//\'0\'的Asic是48，减去48转成数字\r\n		if ((pHugeInteger1 + 1) != HugeInteger1) {\r\n			m = *pHugeInteger1 - 48;\r\n			pHugeInteger1--;\r\n		}\r\n		if ((pHugeInteger2 + 1) != HugeInteger2) {\r\n			n = *pHugeInteger2 - 48;\r\n			pHugeInteger2--;\r\n		}\r\n		//为p指针的第i个字符赋值\r\n		*(p + i) = (m + n + c) % 10 + 48;\r\n		//取得进位\r\n		c = (m + n + c) / 10;\r\n	}\r\n	*p = 48 + c;\r\n\r\n	if(*p==\'0\'){                        //如果结果的第一位是‘0’，表示没有进位\r\n		return p+1;                     //返回第二位的指针，以去除第一位多余的0\r\n	}\r\n	return p;\r\n}\r\n\r\n//减法运算\r\nchar* getSubNumber(char* HugeInteger1,char* HugeInteger2){\r\n\r\n	int isNegative=0;                   //定义结果是否为负数的标志，初始为0,不是负数\r\n\r\n	int lHugeInteger1 = strlen(HugeInteger1), lHugeInteger2 = strlen(\r\n			HugeInteger2);\r\n	if (lHugeInteger1 > lHugeInteger2) { //HugeInteger1的位数大于HugeInteger2，则HugeInteger1大\r\n		isNegative=0;\r\n	} else if (lHugeInteger1 < lHugeInteger2) { //HugeInteger1的位数小于HugeInteger2,则HugeInteger1小\r\n		char* temp = HugeInteger1;\r\n		HugeInteger1 = HugeInteger2;\r\n		HugeInteger2 = temp;\r\n\r\n		isNegative=1;\r\n	} else {                                                  //位数相等\r\n		char* pHugeInteger1 = HugeInteger1;\r\n		char* pHugeInteger2 = HugeInteger2;\r\n\r\n		for (int c = 0; c < lHugeInteger1; c++) {                  //依次比较每一位数的大小\r\n			if ((*(pHugeInteger1+c)) > (*(pHugeInteger2+c))) {         //不等，则比较大小\r\n				isNegative=0;\r\n				break;\r\n			} else if ((*(pHugeInteger1+c)) <(*(pHugeInteger2+c))) {\r\n				char* temp = HugeInteger1;\r\n				HugeInteger1 = HugeInteger2;\r\n				HugeInteger2 = temp;\r\n				isNegative = 1;\r\n				break;\r\n			} else {                                          //相等继续\r\n				continue;\r\n			}\r\n		}\r\n	}\r\n\r\n	int maxlen = max(strlen(HugeInteger1), strlen(HugeInteger2));\r\n	//应为HugeInteger1始终大于HugeInteger2,不考虑被减数最高位不够减的情况\r\n	char* p = new char[maxlen + 1];\r\n	//最后一位是结束符\r\n	*(p + maxlen) = \'\\0\';\r\n	//声明两个指针分别指向HugeInteger1和HugeInteger2的末尾，不包含结束符\r\n	char* pHugeInteger1 = HugeInteger1 + strlen(HugeInteger1) - 1;\r\n	char* pHugeInteger2 = HugeInteger2 + strlen(HugeInteger2) - 1;\r\n	int m = 0;\r\n	int n = 0;\r\n	//借位位\r\n	int c = 0;\r\n	for (int i = maxlen - 1; i >=0; i--) {\r\n		m = n = 0;\r\n		//\'0\'的Asic是48，减去48转成数字\r\n		if ((pHugeInteger1 + 1) != HugeInteger1) {\r\n			m = *pHugeInteger1 - 48;\r\n			pHugeInteger1--;\r\n		}\r\n		if ((pHugeInteger2 + 1) != HugeInteger2) {\r\n			n = *pHugeInteger2 - 48;\r\n			pHugeInteger2--;\r\n		}\r\n		//不够减，要借位\r\n		if (m < n) {\r\n			//为p指针的第i个字符赋值\r\n			*(p + i) = 10 + m - n - c + 48;\r\n			c = 1;\r\n		} else {\r\n			//虽然够减，但是如果再算是借走的一位，那么就小于0了\r\n			if (m - n - c < 0)\r\n				*(p + i) = 10 + m - n - c + 48;\r\n			else {\r\n				*(p + i) = m - n - c + 48;\r\n				c = 0;\r\n			}\r\n		}\r\n	}\r\n	if (isNegative == 1) {\r\n		if (*p == \'0\') {                        //如果结果的第一位是‘0’，表示没有进位\r\n			char* temp = new char[maxlen];\r\n			temp = p + 1;                            //返回第二位的指针，以去除第一位多余的0\r\n			char* newp = new char[maxlen + 1];\r\n			*newp = \'-\';                             //首地址带符号‘-’\r\n			for (int i = 0; i < maxlen; i++) {\r\n				*(newp + 1 + i) = *(temp+i);\r\n			}\r\n			return newp;                          //返回带符号的新字符串\r\n		}\r\n		else {\r\n			char* temp2 = new char[maxlen+1];\r\n			temp2 = p ;\r\n			char* newp2 = new char[maxlen +2];\r\n			*newp2 = \'-\';                             //首地址带符号‘-’\r\n			for (int i = 0; i < maxlen+1; i++) {\r\n				*(newp2 + 1 + i) = *(temp2+i);\r\n			}\r\n			return newp2;                          //返回带符号的新字符串\r\n		}\r\n	}\r\n	else {\r\n		if (*p == \'0\') {                        //如果结果的第一位是‘0’，表示没有进位\r\n			return p+1;                     //返回第二位的指针，以去除第一位多余的0\r\n		}\r\n		return p;\r\n	}\r\n}\r\n\r\n//乘法运算\r\nchar* getMultNumber(char* a, char* b) {\r\n	int sizea = strlen(a);\r\n	int sizeb = strlen(b);\r\n	char* p = new char[sizea + sizeb + 1];\r\n//两数相乘所得的积的位数最大为两个数位数只和，多申请一位放\'\\0\'\r\n	char* pA = a + sizea - 1;\r\n	char* pB = b + sizeb - 1;\r\n	int m = 0;\r\n	int n = 0;\r\n	//进位\r\n	int c = 0;\r\n//存放该位置原有的数\r\n	int s = 0;\r\n//记数\r\n	int i = 0;\r\n	int j = 0;\r\n//具体实现过程详见说明文件\r\n	for (i = 0; i < sizea; i++) {\r\n		m = *(pA - i) - 48;\r\n		c = 0;\r\n		for (j = 0; j < sizeb; j++) {\r\n			n = *(pB - j) - 48;\r\n//判断该位置原来是否为0\r\n			if ((*(p + i + j) >= \'0\') && (*(p + i + j) <= \'9\'))\r\n				s = *(p + i + j) - 48;\r\n			else\r\n				s = 0;\r\n			*(p + i + j) = (m * n + c + s) % 10 + 48;\r\n			c = (m * n + c + s) / 10;\r\n		}\r\n		*(p + i + j) = 48 + c;\r\n	}\r\n	if (c > 0)\r\n		*(p + i + j) = \'\\0\';\r\n	else\r\n		*(p + i + j - 1) = \'\\0\';\r\n\r\n	int size1 = strlen(p) - 1;\r\n	int size2 = (size1 + 1) / 2;\r\n	char temp;\r\n	for (int i = 0; i < size2; i++) {\r\n		temp = p[i];\r\n		p[i] = p[size1 - i];\r\n		p[size1 - i] = temp;\r\n	}\r\n	return p;\r\n}\r\n\r\n//除法运算（保留个位）\r\nstring getDivNumber(const string &str1,const string &str2)  //  str1/str2\r\n{\r\n    int i;\r\n    int length,len1,len2,len,index;\r\n    bool flag;\r\n\r\n    len1=str1.length();\r\n    len2=str2.length();\r\n    length=len1-len2;\r\n    if(length<0) return \"0\";\r\n\r\n    int *num1=new int[len1+1];\r\n    int *num2=new int[len2+1];\r\n    int *quotient=new int[length+2];\r\n\r\n    memset(num1,0,sizeof(int)*(len1+1));\r\n    memset(num2,0,sizeof(int)*(len2+1));\r\n    memset(quotient,0,sizeof(int)*(length+2));\r\n\r\n    for(i=len1-1,index=0;i>=0;i--)\r\n    {\r\n        num1[index++]=str1[i]-\'0\';\r\n    }\r\n    for(i=len2-1,index=0;i>=0;i--)\r\n    {\r\n        num2[index++]=str2[i]-\'0\';\r\n    }\r\n\r\n    while(true)\r\n    {\r\n        for(i=len1-1;i>=0;i--)\r\n        {\r\n            if(num1[i])\r\n            {\r\n                len1=i+1;\r\n                break;\r\n            }\r\n            if(i==0) len1=0;\r\n        }\r\n\r\n        len=len1-len2;\r\n        if(len<0) break;\r\n\r\n        flag=false;\r\n        index=0;\r\n\r\n        for(i=len1-1;i>=len;i--)\r\n        {\r\n            if(num1[i]==num2[i-len]) continue;\r\n            else if(num1[i]<num2[i-len])\r\n            {\r\n                flag=true;\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(flag) --len;\r\n        if(len<0) break;\r\n\r\n        while(++index)\r\n        {\r\n            flag=false;\r\n            for(i=len1-1;i>=len;i--)\r\n            {\r\n                if(num1[i]==num2[i-len]) continue;\r\n                else if(num1[i]<num2[i-len])\r\n                {\r\n                    flag=true;\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            if(flag)\r\n            {\r\n                --index;\r\n                break;\r\n            }\r\n\r\n            for(i=len;i<len1;i++)\r\n            {\r\n                num1[i]-=num2[i-len];\r\n                if(num1[i]<0)\r\n                {\r\n                    num1[i]+=10;\r\n                    --num1[i+1];\r\n                }\r\n            }\r\n        }\r\n        if(index==0) break;\r\n        else quotient[len]=index;\r\n    }\r\n\r\n    string ans;\r\n    flag=false;\r\n    for(i=length;i>=0;i--)\r\n    {\r\n        if(flag||quotient[i])\r\n        {\r\n            flag=true;\r\n            ans+=\'0\'+quotient[i];\r\n        }\r\n    }\r\n    if(!flag) ans=\"0\";\r\n\r\n    delete [] num1;\r\n    delete [] num2;\r\n    delete [] quotient;\r\n\r\n    return ans;\r\n}\r\n\r\n//重载<<\r\nostream& operator<<(ostream& output, const HugeInteger& aHugeInter) {\r\n\r\n	output << aHugeInter.hugeInteger;\r\n	return output;\r\n}\r\n\r\n//重载+\r\nHugeInteger operator +(const HugeInteger& aHugeInteger,\r\n		const HugeInteger& bHugeInteger) {\r\n\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b = bHugeInteger.hugeInteger.c_str();\r\n\r\n	return HugeInteger(getAddNumber((char*)a,(char*)b));\r\n\r\n}\r\nHugeInteger operator +(const HugeInteger& aHugeInteger, const string s){\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b = s.c_str();\r\n\r\n	return HugeInteger(getAddNumber((char*)a,(char*)b));\r\n}\r\nHugeInteger operator +(const HugeInteger& aHugeInteger, const int i){\r\n	char t[256];\r\n	sprintf(t, \"%d\", i);\r\n	string temp=t;\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b =temp.c_str();\r\n\r\n	return HugeInteger(getAddNumber((char*)a,(char*)b));\r\n}\r\n\r\n//重载-\r\nHugeInteger operator -(const HugeInteger& aHugeInteger,\r\n		const HugeInteger& bHugeInteger) {\r\n\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b = bHugeInteger.hugeInteger.c_str();\r\n\r\n	return HugeInteger(getSubNumber((char*)a,(char*)b));\r\n\r\n}\r\nHugeInteger operator -(const HugeInteger& aHugeInteger, const string s){\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b = s.c_str();\r\n\r\n	return HugeInteger(getSubNumber((char*)a,(char*)b));\r\n}\r\n\r\nHugeInteger operator -(const HugeInteger& aHugeInteger, const int i){\r\n	char t[256];\r\n	sprintf(t, \"%d\", i);\r\n	string temp=t;\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b =temp.c_str();\r\n\r\n	return HugeInteger(getSubNumber((char*)a,(char*)b));\r\n}\r\n//重载*\r\nHugeInteger operator *(const HugeInteger& aHugeInteger,\r\n		const HugeInteger& bHugeInteger) {\r\n\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b = bHugeInteger.hugeInteger.c_str();\r\n\r\n	return HugeInteger(getMultNumber((char*)a,(char*)b));\r\n\r\n}\r\nHugeInteger operator *(const HugeInteger& aHugeInteger, const string s){\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b = s.c_str();\r\n\r\n	return HugeInteger(getMultNumber((char*)a,(char*)b));\r\n}\r\n\r\nHugeInteger operator *(const HugeInteger& aHugeInteger, const int i){\r\n\r\n	char t[256];\r\n	sprintf(t, \"%d\", i);\r\n	string temp=t;\r\n	const char* a = aHugeInteger.hugeInteger.c_str();    //sting转换成char*\r\n	const char* b =temp.c_str();\r\n\r\n	return HugeInteger(getMultNumber((char*)a,(char*)b));\r\n}\r\n\r\n//重载/\r\nHugeInteger operator /(const HugeInteger& aHugeInteger,\r\n		const HugeInteger& bHugeInteger) {\r\n\r\n	return HugeInteger(getDivNumber(aHugeInteger.hugeInteger,bHugeInteger.hugeInteger));\r\n\r\n}\r\nHugeInteger operator /(const HugeInteger& aHugeInteger, const string s){\r\n\r\n	return HugeInteger(getDivNumber(aHugeInteger.hugeInteger,s));\r\n}\r\n\r\nHugeInteger operator /(const HugeInteger& aHugeInteger, const int i){\r\n\r\n	char t[256];\r\n	sprintf(t, \"%d\", i);\r\n	string temp=t;\r\n\r\n	return HugeInteger(getDivNumber(aHugeInteger.hugeInteger,temp));\r\n}\r\n\r\n```\r\n\r\n**测试类：**\r\n\r\n```\r\n#include <iostream>\r\n#include \"HugeInteger.h\"\r\nusing namespace std;\r\n\r\nint main() {\r\n\r\n	HugeInteger n1(7654321);\r\n	HugeInteger n2(7891234);\r\n	HugeInteger n3(\"99999999999999999999999999999\");\r\n	HugeInteger n4(\"1\");\r\n	HugeInteger n5;\r\n\r\n	cout << \"n1 is \" << n1 << \"\\nn2 is \" << n2 << \"\\nn3 is \" << n3 << \"\\nn4 is \"\r\n			<< n4 << \"\\nn5 is \" << n5 << \"\\n\\n\";\r\n\r\n	n5 = n1 + n2;\r\n	cout << n1 << \" + \" << n2 << \" = \" << n5 << \"\\n\\n\";\r\n\r\n	n5 = n1 - n2;              //小减大\r\n	cout << n1 << \" - \" << n2 << \" = \" << n5 << \"\\n\\n\";\r\n	n5 = n2- n1;               //大减小\r\n	cout << n2<< \" - \" << n1<< \" = \" << n5 << \"\\n\\n\";\r\n\r\n	n5 = n2 * n1;               //乘法\r\n	cout << n2 << \" * \" << n1 << \" = \" << n5 << \"\\n\\n\";\r\n\r\n	n5 = n2 / n1;               //除法  保留到整数\r\n	cout << n2 << \" / \" << n1 << \" = \" << n5 << \"\\n\\n\";\r\n\r\n	cout << n3 << \" + \" << n4 << \"\\n= \" << (n3 + n4) << \"\\n\\n\";\r\n\r\n	n5 = n1 + 9;               //与int类型运算\r\n	cout << n1 << \" + \" << 9 << \" = \" << n5 << \"\\n\\n\";\r\n\r\n	n5 = n2 + \"10000\";         //与string类型运算\r\n	cout << n2 << \" + \" << \"10000\" << \" = \" << n5 << endl;\r\n\r\n	n5 = n2 * \"10000\";         //乘法运算\r\n	cout << n2 << \" * \" << \"10000\" << \" = \" << n5 << endl;\r\n\r\n	n2= n5 /\"10000\";         //除法运算\r\n	cout << n5<< \" / \" << \"10000\" << \" = \" << n2<< endl;\r\n\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n### 三、实验结果和截图\r\n\r\n', '1', 'post', 'publish', 'C++', 'C/C++', '3', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('27', '【C++】基于C＋＋的封装和运算符重载的思想，实现基于通讯录类的数据查询工作', null, '1520480385', '1520480683', '### 一、实验项目内容\r\n    1、实现通讯录条目类（姓名、性别和电话号码），并为每个属性设置 set和get方法，并实现输入／输出运算符重载功能；\r\n    \r\n    2、从通讯录的文本文件“record.txt”中读取数据放到通讯录条目类实例化的对象中，并合理组织存储结果方便查找。其文件样例如下，文件第一行为通讯录中人员的个数n，从第二行到第n+1行是n个通讯录； 每个通讯录占1行，每行依次为人员姓名、性别和电话号码，每个属性间以空格隔开。\r\n        3\r\n        张三 男 123456\r\n        李四 女 654321\r\n        张三 男 654321\r\n    \r\n    3、从文本文件“query.txt”，查询指定列的数据，样例如下，只有1行，第1个数据是指查询的数据在“record.txt”对应的列数，第二个数据是查询的关键词。\r\n        1 张三\r\n    \r\n    4、将查询到的结果输出到“result.txt”文件中，根据前面的“record.txt”和“query.txt”的样例，“result.txt”输出样例如下，注意将查到所有    的结果都输出。\r\n        张三 男 123456\r\n        张三 男 654321\r\n### 二、实验过程或算法\r\n**程序流程图：**\r\n![这里写图片描述](http://img.blog.csdn.net/20170817221325293?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**Member.h:**\r\n```\r\n#ifndef MEMBER_H\r\n#define MEMBER_H\r\n\r\n#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nclass Member {                           //成员remeber相关信息类\r\n\r\nprivate:\r\n	string name;\r\n	string gender;\r\n	string tel;\r\n\r\npublic:\r\n\r\n	Member();                           //默认构造函数\r\n\r\n	Member(string name,string gender,string tel);  //构造函数\r\n\r\n	string getGender();                //Getting and setting\r\n\r\n	string getName();\r\n\r\n	string getTel();\r\n\r\n	void setGender(string gender);\r\n\r\n	void setName(string name) ;\r\n\r\n	void setTel(string tel);\r\n\r\n};\r\n#endif\r\n\r\n```\r\n**Member.cpp**\r\n```\r\n#include \"Member.h\"\r\n\r\nMember::Member() {                     //默认构造函数\r\n	this->name = \"NULL\";\r\n	this->gender = \"NULL\";\r\n	this->tel = \"NULL\";\r\n}\r\n\r\nMember::Member(string name, string gender, string tel) {    //构造函数\r\n	this->name = name;\r\n	this->gender = gender;\r\n	this->tel = tel;\r\n}\r\n/*\r\n * Getting and setting\r\n * */\r\nstring Member::getGender()  {\r\n	return gender;\r\n}\r\n\r\nstring Member::getName()  {\r\n	return name;\r\n}\r\n\r\nstring Member::getTel()  {\r\n	return tel;\r\n}\r\nvoid Member::setGender(string gender) {\r\n	this->gender = gender;\r\n}\r\n\r\nvoid Member::setName(string name) {\r\n	this->name = name;\r\n}\r\n\r\nvoid Member::setTel(string tel) {\r\n	this->tel = tel;\r\n}\r\n\r\n```\r\n**QueryManger.h:**\r\n```\r\n#ifndef QUERYMANGER_H\r\n#define QUERYMANGER_H\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <list>\r\n#include <fstream>\r\n#include <sstream>\r\n#include \"Member.h\"\r\nusing namespace std;\r\n\r\nclass QueryManger{                                                       //封装查询类：QueryManger\r\npublic:\r\n	QueryManger(list<Member> members,string queryL,string queryInfo);    //构造函数\r\n\r\n	list<Member> getMembers();                                           //getting\r\n\r\n	void queryNmae();                                                    //查询Name\r\n	void queryGender();                                                  //查询Gender\r\n	void queryTel();                                                     //查询Telephone\r\n\r\n	friend ostream& operator<<(ostream& output, const QueryManger& queryManger) ;\r\n	friend istream& operator>>(istream& input, QueryManger& queryManger) ;\r\n\r\n\r\nprivate:\r\n	list<Member> members;                                                //查询对象集合\r\n	list<Member>::iterator it;\r\n	list<Member> queryMembers;                                           //查询结果集合\r\n	string queryL;                                                       //查询所在列\r\n	string queryInfo;                                                    //查询的信息\r\n};\r\n#endif\r\n\r\n```\r\n**QueryManger.cpp:**\r\n```\r\n#include \"QueryManger.h\"\r\n\r\nQueryManger::QueryManger(list<Member> members, string queryL,   //构造函数\r\n		string queryInfo) {\r\n	this->members = members;\r\n	this->queryL = queryL;\r\n	this->queryInfo = queryInfo;\r\n\r\n	this->queryMembers=getMembers();\r\n}\r\n\r\nlist<Member> QueryManger::getMembers() {                        //getting查询结果\r\n	if (queryL == \"1\") {\r\n		queryNmae();                                            //第一列==Nmae\r\n	}\r\n	if (queryL == \"2\") {                                        //第二列==Gender\r\n		queryGender();\r\n	}\r\n	if (queryL == \"3\") {\r\n		queryTel();                                             //第三列==Telephone\r\n	}\r\n	return queryMembers;\r\n}\r\n\r\nvoid QueryManger::queryNmae() {                                //查询Name\r\n	for (it = members.begin(); it != members.end(); it++) {\r\n		Member temp = *it;\r\n		if (temp.getName().compare(queryInfo) == 0) {\r\n			queryMembers.push_back(temp);\r\n		}\r\n	}\r\n}\r\nvoid QueryManger::queryGender() {                            //查询Gender\r\n	for (it = members.begin(); it != members.end(); it++) {\r\n		Member temp = *it;\r\n		if (temp.getGender().compare(queryInfo) == 0) {\r\n			queryMembers.push_back(temp);\r\n		}\r\n	}\r\n}\r\nvoid QueryManger::queryTel() {                               //查询Telephone\r\n	for (it = members.begin(); it != members.end(); it++) {\r\n		Member temp = *it;\r\n		if (temp.getTel().compare(queryInfo) == 0) {\r\n			queryMembers.push_back(temp);\r\n		}\r\n	}\r\n}\r\n\r\nostream& operator<<(ostream& output, const QueryManger& queryManger){\r\n\r\n	list<Member> it=queryManger.queryMembers;\r\n	cout<<\"询信息:\"<<queryManger.queryL<<\" \"<<queryManger.queryInfo<<\"\\n查询结果：\"<<endl;\r\n	ofstream fout(\"result.txt\");          //查询结果写入文件\r\n\r\n	while(it.size()!=0){\r\n		fout<<it.front().getName()<<\" \"<<it.front().getGender()<<\" \"<<it.front().getTel()<<endl;\r\n		output<<it.front().getName()<<\" \"<<it.front().getGender()<<\" \"<<it.front().getTel()<<endl;\r\n		it.pop_front();\r\n	}\r\n\r\n	fout.close();\r\n	return output;\r\n}\r\n\r\nistream& operator>>(istream& input, QueryManger& queryManger) {\r\n	Member in;\r\n	string temp;\r\n	cout << \"Please input name:\";\r\n	input >> temp;\r\n	in.setName(temp);\r\n	cout << \"Please input gender:\";\r\n	input>> temp;\r\n	in.setGender(temp);\r\n	cout << \"Please input tel:\";\r\n	input>> temp;\r\n	in.setTel(temp);\r\n\r\n	queryManger.members.push_back(in);\r\n\r\n	list<Member> it = queryManger.members;\r\n	ofstream fout(\"record.txt\");          //查询结果写入文件\r\n	fout <<it.size()<< endl;\r\n	while (it.size() != 0) {\r\n		fout << it.front().getName() << \" \" << it.front().getGender() << \" \"\r\n				<< it.front().getTel() << endl;\r\n		it.pop_front();\r\n	}\r\n	fout.close();\r\n\r\n	return input;\r\n}\r\n\r\n```\r\n**测试类：**\r\n```\r\n#include <iostream>\r\n#include <list>\r\n#include <fstream>\r\n#include <sstream>\r\n#include \"Member.h\"\r\n#include \"QueryManger.h\"\r\nusing namespace std;\r\n\r\nint main() {\r\n	cout << \"!!!Hello,Welcome!!!\" <<\"\\n记录信息为：\"<< endl; // prints !!!Hello World!!!\r\n	list<Member> members;                  //被查询对象\r\n	list<Member> queryMembers;             //查询结果对象\r\n	list<Member>::iterator it;\r\n\r\n    string name,gender,tel,queryL,queryInfo; //定义：姓名，性别，电话号码，列，查询信息\r\n    int count=0;\r\n\r\n	ifstream inRecord(\"record.txt\");       //被查询的文件\r\n	ifstream inQuery(\"query.txt\");         //查询信息\r\n\r\n	for(string s;getline(inRecord,s);){\r\n		if(count==0){\r\n			count++;\r\n		}\r\n		else {\r\n			cout << s << endl;                                               //输出对象\r\n			istringstream isRecord(s);\r\n			isRecord >> name >> gender >> tel;\r\n\r\n			Member member(name,gender,tel);\r\n\r\n			members.push_back(member);                                         //遍历，得到被查寻对象\r\n		}\r\n	}\r\n\r\n	for (string s; getline(inQuery, s);) {\r\n\r\n		istringstream isQuery(s);\r\n		isQuery>> queryL >> queryInfo;                                        //得到查询信息\r\n	}\r\n\r\n	QueryManger queryManger(members,queryL,queryInfo);                        //构造QueryManger\r\n\r\n//	queryMembers=queryManger.getMembers();                                    //获取查询结果\r\n//	cout<<\"询信息:\"<<queryL<<\" \"<<queryInfo<<\"\\n查询结果：\"<<endl;\r\n	cout<<queryManger;                                                       //重构输出方式,输出查询结果\r\n//	ofstream fout(\"result.txt\");          //查询结果写入文件\r\n//	for(it=queryMembers.begin();it!=queryMembers.end();it++){                //\r\n//		Member temp=*it;\r\n//		fout<<temp.getName()<<\" \"<<temp.getGender()<<\" \"<<temp.getTel()<<endl;\r\n//		cout<<temp.getName()<<\" \"<<temp.getGender()<<\" \"<<temp.getTel()<<endl;\r\n//	}\r\n//\r\n//	fout.close();\r\n\r\n	cin>>queryManger;                                                        //重构输入方式，写入新的信息\r\n	return 0;\r\n}\r\n```\r\n\r\n### 三、实验结果和截图\r\n![这里写图片描述](http://img.blog.csdn.net/20170817222057316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170817222112128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170817222130650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170817222142692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)', '1', 'post', 'publish', 'C++', 'C/C++', '1', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('28', '【C++】基于linux文件管理和C＋＋的I/O框架，实现命令行下的文件管理器', null, '1520480418', '1520480611', '### 一、实验项目内容\r\n1、实现文件夹创建、删除、进入。\r\n2、实现当前文件夹下的内容罗列。\r\n3、实现文件拷贝和文件夹拷贝（文件夹拷贝指深度拷贝，包括所有子目录和文件）。\r\n### 二、实验过程或算法\r\n**DocumentManger.h**\r\n```\r\n#ifndef CIRCLE_H\r\n#define CIRCLE_H\r\n\r\n#include<stdlib.h>\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <unistd.h>\r\n#include <dirent.h>\r\n#include <string.h>\r\n#include<sstream>\r\n#include<iostream>\r\n#include <dirent.h>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nclass DocumentManager {                         //DocumentManger 文件管理类\r\n\r\nprivate:\r\n	char *path;\r\n	char *newpath;\r\npublic:\r\n	DocumentManager();                         //构造函数1\r\n	DocumentManager( char *path);              //构造函数2\r\n\r\n	void setNewpath( char* newpath);\r\n	void setPath( char* path);\r\n	void displayTips();                            //命令提示行\r\n\r\n	int make_dir(const char *path, mode_t mode);   //创建文件夹\r\n	int change_dir(const char *path);              //改变路径\r\n	int remove_dir(const char* path);              //移除文件夹\r\n	int get_file_size_time(const char *filename);  //获取文件的信息\r\n	DIR * open_dir(const char *path);              //打开文件夹\r\n	void read_dir(const char *path, bool ListAllFiles);    //读取文件夹\r\n	int copy_dir(const char *filename, const char *newfilename);   //拷贝文件夹\r\n\r\n};\r\n\r\n#endif\r\n\r\n```\r\n\r\n**DocumentManager.cpp**\r\n\r\n```\r\n#include \"DocumentManager.h\"\r\n\r\nDocumentManager::DocumentManager() {\r\n	this->path = NULL;\r\n}\r\nDocumentManager::DocumentManager(char *path) {\r\n	this->path = path;\r\n}\r\n\r\n\r\nvoid DocumentManager::setNewpath(char* newpath) {\r\n	this->newpath = newpath;\r\n}\r\n\r\nvoid DocumentManager::setPath(char* path) {           //store this current path\r\n	this->path = path;\r\n}\r\n\r\nvoid DocumentManager::displayTips() {                 //display these tips\r\n	cout << \"please input commands as the following: \" << endl;\r\n	cout << \"0.mkdir [path]\" << endl;\r\n	cout << \"1.chdir [path]\" << endl;\r\n	cout << \"2.rmdir [path]\" << endl;\r\n	cout << \"3.opendir [path]\" << endl;\r\n	cout << \"4.readdir [path]\" << endl;\r\n	cout << \"5.lldir [path]\" << endl;\r\n	cout << \"5.copy [path] [newPath]\" << endl;\r\n	cout << \"7.exit\" << endl;\r\n}\r\n\r\nint DocumentManager::make_dir(const char *path, mode_t mode){\r\n	if (mkdir(path,mode) != 0) {                       //make dir with mode\r\n		cerr << \"make dir fail\" << endl;\r\n	} else {\r\n		cout << \"make dir success\" << endl;\r\n	}\r\n	return 0;\r\n}\r\nint DocumentManager::get_file_size_time(const char *filename)\r\n{\r\n	struct stat statbuf;                               //get the informations of file\r\n	if (stat(filename, &statbuf) == -1) {\r\n		cerr << \"Get stat on\" << filename << \"  Error: \" << endl;\r\n		cerr << strerror(errno) << endl;\r\n	}\r\n	if (S_ISDIR(statbuf.st_mode)) {\r\n	}\r\n	if (S_ISREG(statbuf.st_mode)) {\r\n		cout << filename << \" size:\" << statbuf.st_size << \" bytes\"\r\n				<< \" modified at \" << ctime(&statbuf.st_mtime) << endl;\r\n	}\r\n\r\n	return 0;\r\n\r\n}\r\nint DocumentManager::change_dir(const char *path ){   //change the dir\r\n	this->path=(char*)path;\r\n\r\n	if (chdir(path) != 0) {\r\n		cout << \"change dir fail\" << endl;\r\n	} else {\r\n		cout << \"change dir success\" << endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\nint DocumentManager::remove_dir(const char* path){    //remove dir\r\n	DIR *dirp=opendir(path);\r\n	if(dirp==NULL){                                   //打开文件夹失败\r\n	    perror(path);                                 //输出错误的原因\r\n	    return 0;\r\n	}\r\n	struct dirent *entry;\r\n	int ret;\r\n	while (1) {\r\n		entry = readdir(dirp);\r\n		if (entry == NULL) {                          //若父目录为空，直接退出循环\r\n			break;\r\n		}\r\n		if(strcmp(\".\",entry->d_name)==0||strcmp(\"..\",entry->d_name)==0){\r\n			continue;\r\n		}\r\n		char buf[80];\r\n		snprintf(buf,80,\"%s/%s\",path,entry->d_name);  //重构子目录\r\n		ret=remove(buf);                              //delete these files\r\n		if(ret==-1){\r\n			if(errno==ENOTEMPTY){                     //删除失败\r\n				remove_dir(buf);\r\n				continue;\r\n			}\r\n			perror(buf);                              //输出失败的原因\r\n			return 0;\r\n		}\r\n\r\n	}\r\n\r\n	closedir(dirp);\r\n	ret=rmdir(path);                                  //delete the empty dir\r\n	if(ret==-1){\r\n		perror(path);\r\n	}\r\n	else{\r\n		cout<<\"remove dir success!\"<<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\nDIR * DocumentManager::open_dir(const char *path) {\r\n	DIR *dirp=opendir(path);                          //open the dir\r\n	if (dirp!= NULL) {\r\n		cout << \"open dir success\" << endl;\r\n	}\r\n	else{\r\n		cerr<<\"Open Directory\"<<path<<\"  Error: \"<<endl;\r\n		cerr<<strerror(errno)<<endl;\r\n	}\r\n	closedir(dirp);                                    //closedir\r\n	return dirp;\r\n}\r\n\r\nvoid DocumentManager::read_dir(const char *path,bool JustListFileName)\r\n{\r\n	DIR *dirp=opendir(path);\r\n	struct dirent *direntp;\r\n	static char dot[] = \".\", dotdot[] = \"..\";\r\n	char buf[80];\r\n	while ((direntp = readdir(dirp)) != NULL) {\r\n		if (strcmp(direntp->d_name, dot) && strcmp(direntp->d_name, dotdot)) {\r\n			if (JustListFileName) {                  //just read the filename\r\n				cout << direntp->d_name << endl;\r\n			} else {\r\n				sprintf(buf, \"%s/%s\", path, direntp->d_name);\r\n				if (get_file_size_time(buf) == -1)          //get the information\r\n					break;\r\n			}\r\n		}\r\n	}\r\n	closedir(dirp);                                 //closedir\r\n}\r\n\r\n\r\n\r\nint DocumentManager::copy_dir(const char *filename, const char *newfilename) {\r\n	struct stat cur_file;\r\n	stat(filename, &cur_file);\r\n\r\n	if (S_ISDIR(cur_file.st_mode)) {               //路径是文件夹\r\n		DIR *cur_dir;\r\n		dirent *cur_ent;\r\n		int errnum = 0;\r\n\r\n		if ((cur_dir = opendir(filename)) == NULL){\r\n			return 1;\r\n		}\r\n		if (access(newfilename, F_OK)){          //文件夹不存在，创建这个目标文件夹\r\n			errnum |= mkdir(newfilename, S_IRWXU);\r\n		}\r\n		while ((cur_ent = readdir(cur_dir)) != NULL)    //递归，复制子目录\r\n			if (strcmp(cur_ent->d_name, \".\") && strcmp(cur_ent->d_name, \"..\")) {\r\n				errnum |= copy_dir(((string)filename + \"/\" + cur_ent->d_name).c_str(),\r\n						((string)newfilename + \"/\" + cur_ent->d_name).c_str());\r\n			}\r\n		closedir(cur_dir);                       //close dir\r\n		return errnum;\r\n	} else {                                    //路径是文件名\r\n		if (filename == newfilename){           //若两个路径相同则视为无效，退出\r\n			return 0;\r\n		}\r\n		fstream fsin, fsout;                   //拷贝文件\r\n		fsin.open(filename,ios::in | ios::binary);\r\n		fsout.open(newfilename, ios::out |ios::binary);\r\n		fsout << fsin.rdbuf();\r\n		return 1;\r\n	}\r\n}\r\n\r\n```\r\n**DocumenManger的测试类：**\r\n```\r\n#include \"DocumentManager.h\"\r\n#include<stdlib.h>\r\n#include <stdio.h>\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <unistd.h>\r\n#include <dirent.h>\r\n#include <errno.h>\r\n#include <string.h>\r\n#include<sstream>\r\n#include<iostream>\r\n#include <dirent.h>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nint main(){\r\n\r\n	DocumentManager documentmanger;              //declare a DocumentManager\r\n\r\n	documentmanger.displayTips();                //outputs the tips\r\n\r\n	string input, command, path, newPath;\r\n	int i;\r\n	while (getline(cin, input)) {\r\n		istringstream is(input);\r\n		string s;                                //deal this inputs\r\n		for (i = 0; is >> s; i++) {\r\n			if (s.compare(\"exit\") == 0) {        //command is exit\r\n				exit(0);\r\n			}\r\n		}\r\n		if (i != 2 & i != 3) {\r\n			cerr << \"your input is Illegal\" << endl;\r\n			continue;\r\n		}\r\n		istringstream temp(input);\r\n		temp >> command >> path >> newPath;\r\n\r\n		if (command.compare(\"mkdir\") == 0) {     //command is mkdir\r\n			const char* pa = path.c_str();\r\n			documentmanger.make_dir(pa, 0755);\r\n		}\r\n		else if (command.compare(\"chdir\") == 0) {//command is chdir\r\n			const char* pa = path.c_str();\r\n			documentmanger.change_dir(pa);\r\n\r\n		}\r\n		else if (command.compare(\"rmdir\") == 0) {//command is rmdir\r\n			const char* pa = path.c_str();\r\n			documentmanger.remove_dir((char* )pa);\r\n		}\r\n		else if (command.compare(\"opendir\") == 0) {//command is opendir\r\n			const char* pa = path.c_str();\r\n			documentmanger.open_dir((pa));\r\n		}\r\n		else if (command.compare(\"readdir\") == 0) {//command is readdir\r\n			const char* pa = path.c_str();\r\n			documentmanger.read_dir(pa,1);\r\n		}\r\n		else if (command.compare(\"lldir\") == 0) {//command is lldir\r\n			const char* pa = path.c_str();\r\n			documentmanger.read_dir(pa,0);\r\n		}\r\n		else if (command.compare(\"copy\") == 0) { //command is copy\r\n			const char* pa = path.c_str();\r\n			const char* npa = newPath.c_str();\r\n			documentmanger.copy_dir(pa, npa);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n```\r\n\r\n### 三、实验结果和截图\r\n![这里写图片描述](http://img.blog.csdn.net/20170817220805215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n![这里写图片描述](http://img.blog.csdn.net/20170817220818841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n![这里写图片描述](http://img.blog.csdn.net/20170817220836920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n![这里写图片描述](http://img.blog.csdn.net/20170817220849285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n![这里写图片描述](http://img.blog.csdn.net/20170817220858857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)', '1', 'post', 'publish', 'C++', 'C/C++', '4', '0', '1', '1', '1');
INSERT INTO `t_contents` VALUES ('29', '【IDEA】Mybatis Plugin插件安装破解及使用', null, '1520480468', '1520480507', 'Mybatis Plugin\r\n### step1:\r\n    在IDEA中下载这个插件，或者在官网中下载mybatis_plus.jar：https://plugins.jetbrains.com/plugin/7293-mybatis-plugin\r\n \r\nhttps://plugins.jetbrains.com/plugin/7293-mybatis-plugin\r\n       \r\n    破解版文件：https://github.com/myoss/profile/tree/master/idea/plugin/MybatisPlugin\r\n https://github.com/myoss/profile/tree/master/idea/plugin/MybatisPlugin\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20170817213356735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n<font  color=#FF4500 face=\"微软雅黑\" size=\"20\">注意版本一致</font>\r\n\r\n### step2:\r\n**安装官方版本**\r\n![这里写图片描述](http://img.blog.csdn.net/20170817213754947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n\r\n**进入安装目录**\r\n![这里写图片描述](http://img.blog.csdn.net/20170817213947835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWRtaW5wZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n### step3:\r\n用压缩工具打开mybatis_plus.jar，用下载好的破解文件替换mybatis_plus.jar里的文件。\r\n\r\n### step4:\r\n重启你的IDEA，完毕，破解搞定。', '1', 'post', 'publish', 'Java,Idea,Mybatis', 'Java', '19', '0', '1', '1', '1');

-- ----------------------------
-- Table structure for t_logs
-- ----------------------------
DROP TABLE IF EXISTS `t_logs`;
CREATE TABLE `t_logs` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `action` varchar(100) DEFAULT NULL,
  `data` varchar(2000) DEFAULT NULL,
  `author_id` int(10) DEFAULT NULL,
  `ip` varchar(20) DEFAULT NULL,
  `created` int(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=47 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_logs
-- ----------------------------
INSERT INTO `t_logs` VALUES ('1', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496815277');
INSERT INTO `t_logs` VALUES ('2', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496815280');
INSERT INTO `t_logs` VALUES ('3', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496815318');
INSERT INTO `t_logs` VALUES ('4', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496815398');
INSERT INTO `t_logs` VALUES ('5', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496815482');
INSERT INTO `t_logs` VALUES ('6', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496815492');
INSERT INTO `t_logs` VALUES ('7', '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', '1', '0:0:0:0:0:0:0:1', '1496815955');
INSERT INTO `t_logs` VALUES ('8', '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', '1', '0:0:0:0:0:0:0:1', '1496815964');
INSERT INTO `t_logs` VALUES ('9', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496989015');
INSERT INTO `t_logs` VALUES ('10', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1496989366');
INSERT INTO `t_logs` VALUES ('11', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497317863');
INSERT INTO `t_logs` VALUES ('12', '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/tian-zhisheng/activities\",\"social_github\":\"https://github.com/zhisheng17\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', '1', '0:0:0:0:0:0:0:1', '1497318696');
INSERT INTO `t_logs` VALUES ('13', '修改个人信息', '{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}', '1', '0:0:0:0:0:0:0:1', '1497319220');
INSERT INTO `t_logs` VALUES ('14', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497319856');
INSERT INTO `t_logs` VALUES ('15', '登录后台', null, '1', '127.0.0.1', '1497321561');
INSERT INTO `t_logs` VALUES ('16', '登录后台', null, '1', '127.0.0.1', '1497322738');
INSERT INTO `t_logs` VALUES ('17', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497323446');
INSERT INTO `t_logs` VALUES ('18', '删除文章', '2', '1', '0:0:0:0:0:0:0:1', '1497323495');
INSERT INTO `t_logs` VALUES ('19', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497427641');
INSERT INTO `t_logs` VALUES ('20', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497428250');
INSERT INTO `t_logs` VALUES ('21', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497428290');
INSERT INTO `t_logs` VALUES ('22', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497428556');
INSERT INTO `t_logs` VALUES ('23', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497674581');
INSERT INTO `t_logs` VALUES ('24', '修改个人信息', '{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}', '1', '0:0:0:0:0:0:0:1', '1497674690');
INSERT INTO `t_logs` VALUES ('25', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497676623');
INSERT INTO `t_logs` VALUES ('26', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497683817');
INSERT INTO `t_logs` VALUES ('27', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1497685128');
INSERT INTO `t_logs` VALUES ('28', '登录后台', null, '1', '127.0.0.1', '1497689032');
INSERT INTO `t_logs` VALUES ('29', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1520399736');
INSERT INTO `t_logs` VALUES ('30', '删除文章', '/upload/2017/06/t93vgdj6o8irgo87ds56u0ou0s.jpeg', '1', '0:0:0:0:0:0:0:1', '1520399857');
INSERT INTO `t_logs` VALUES ('31', '修改密码', null, '1', '0:0:0:0:0:0:0:1', '1520401921');
INSERT INTO `t_logs` VALUES ('32', '修改个人信息', '{\"uid\":1,\"email\":\"375027533@qq.com\",\"screenName\":\"admin\"}', '1', '0:0:0:0:0:0:0:1', '1520401930');
INSERT INTO `t_logs` VALUES ('33', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1520402520');
INSERT INTO `t_logs` VALUES ('34', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1520402533');
INSERT INTO `t_logs` VALUES ('35', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1520406055');
INSERT INTO `t_logs` VALUES ('36', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1520479218');
INSERT INTO `t_logs` VALUES ('37', '删除文章', '3', '1', '0:0:0:0:0:0:0:1', '1520479324');
INSERT INTO `t_logs` VALUES ('38', '删除文章', '4', '1', '0:0:0:0:0:0:0:1', '1520479328');
INSERT INTO `t_logs` VALUES ('39', '删除文章', '8', '1', '0:0:0:0:0:0:0:1', '1520479334');
INSERT INTO `t_logs` VALUES ('40', '删除文章', '5', '1', '0:0:0:0:0:0:0:1', '1520479340');
INSERT INTO `t_logs` VALUES ('41', '删除文章', '6', '1', '0:0:0:0:0:0:0:1', '1520479344');
INSERT INTO `t_logs` VALUES ('42', '保存系统设置', '{\"social_zhihu\":\"\",\"social_github\":\"https://github.com/zas023\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', '1', '0:0:0:0:0:0:0:1', '1520479413');
INSERT INTO `t_logs` VALUES ('43', '登录后台', null, '1', '0:0:0:0:0:0:0:1', '1520482620');
INSERT INTO `t_logs` VALUES ('44', '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"伪代码\",\"site_theme\":\"default\",\"allow_install\":\"\"}', '1', '0:0:0:0:0:0:0:1', '1520485304');
INSERT INTO `t_logs` VALUES ('45', '登录后台', null, '1', '127.0.0.1', '1520490399');
INSERT INTO `t_logs` VALUES ('46', '删除页面', '30', '1', '0:0:0:0:0:0:0:1', '1520490832');

-- ----------------------------
-- Table structure for t_metas
-- ----------------------------
DROP TABLE IF EXISTS `t_metas`;
CREATE TABLE `t_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL DEFAULT '',
  `description` varchar(200) DEFAULT NULL,
  `sort` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_metas
-- ----------------------------
INSERT INTO `t_metas` VALUES ('6', 'my github', 'https://github.com/zas023', 'link', 'http://www.54tianzhisheng.cn/img/avatar.png', '1', '0');
INSERT INTO `t_metas` VALUES ('7', '言曌博客', 'https://liuyanzhao.com/', 'link', 'http://www.54tianzhisheng.cn/img/avatar.png', '0', '0');
INSERT INTO `t_metas` VALUES ('8', '随笔', '随笔', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('9', 'Java', 'Java', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('10', 'Java', 'Java', 'category', '有关Java的博客', '0', '0');
INSERT INTO `t_metas` VALUES ('11', 'HashMap', 'HashMap', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('12', 'HashTable', 'HashTable', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('13', 'HashSet', 'HashSet', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('14', 'ConcurrentHashMap', 'ConcurrentHashMap', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('15', 'Pyspider', 'Pyspider', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('16', 'Python', 'Python', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('19', 'Python', 'Python', 'category', '有关Python的博客', '0', '0');
INSERT INTO `t_metas` VALUES ('20', '随笔', null, 'category', null, '0', '0');
INSERT INTO `t_metas` VALUES ('21', 'ssm', 'ssm', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('23', 'Android', 'Android', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('24', 'Android', null, 'category', null, '0', '0');
INSERT INTO `t_metas` VALUES ('25', '其他', null, 'category', null, '0', '0');
INSERT INTO `t_metas` VALUES ('26', 'Spring', 'Spring', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('27', 'Git', 'Git', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('28', 'VS', 'VS', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('29', 'Markdown', 'Markdown', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('30', 'C/C++', null, 'category', null, '0', '0');
INSERT INTO `t_metas` VALUES ('31', 'C++', 'C++', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('32', 'Idea', 'Idea', 'tag', null, '0', '0');
INSERT INTO `t_metas` VALUES ('33', 'Mybatis', 'Mybatis', 'tag', null, '0', '0');

-- ----------------------------
-- Table structure for t_options
-- ----------------------------
DROP TABLE IF EXISTS `t_options`;
CREATE TABLE `t_options` (
  `name` varchar(32) NOT NULL DEFAULT '',
  `value` varchar(1000) DEFAULT '',
  `description` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_options
-- ----------------------------
INSERT INTO `t_options` VALUES ('allow_install', '', '');
INSERT INTO `t_options` VALUES ('site_description', 'SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统', null);
INSERT INTO `t_options` VALUES ('site_keywords', 'Blog', null);
INSERT INTO `t_options` VALUES ('site_theme', 'default', null);
INSERT INTO `t_options` VALUES ('site_title', '伪代码', '');
INSERT INTO `t_options` VALUES ('social_github', 'https://github.com/zas023', null);
INSERT INTO `t_options` VALUES ('social_twitter', '', null);
INSERT INTO `t_options` VALUES ('social_weibo', '', null);
INSERT INTO `t_options` VALUES ('social_zhihu', '', null);

-- ----------------------------
-- Table structure for t_relationships
-- ----------------------------
DROP TABLE IF EXISTS `t_relationships`;
CREATE TABLE `t_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_relationships
-- ----------------------------
INSERT INTO `t_relationships` VALUES ('7', '9');
INSERT INTO `t_relationships` VALUES ('7', '10');
INSERT INTO `t_relationships` VALUES ('7', '21');
INSERT INTO `t_relationships` VALUES ('9', '9');
INSERT INTO `t_relationships` VALUES ('9', '10');
INSERT INTO `t_relationships` VALUES ('10', '9');
INSERT INTO `t_relationships` VALUES ('10', '10');
INSERT INTO `t_relationships` VALUES ('11', '9');
INSERT INTO `t_relationships` VALUES ('11', '10');
INSERT INTO `t_relationships` VALUES ('12', '9');
INSERT INTO `t_relationships` VALUES ('12', '10');
INSERT INTO `t_relationships` VALUES ('13', '9');
INSERT INTO `t_relationships` VALUES ('13', '10');
INSERT INTO `t_relationships` VALUES ('14', '9');
INSERT INTO `t_relationships` VALUES ('14', '10');
INSERT INTO `t_relationships` VALUES ('15', '9');
INSERT INTO `t_relationships` VALUES ('15', '10');
INSERT INTO `t_relationships` VALUES ('16', '9');
INSERT INTO `t_relationships` VALUES ('16', '10');
INSERT INTO `t_relationships` VALUES ('17', '9');
INSERT INTO `t_relationships` VALUES ('17', '23');
INSERT INTO `t_relationships` VALUES ('17', '24');
INSERT INTO `t_relationships` VALUES ('18', '25');
INSERT INTO `t_relationships` VALUES ('19', '25');
INSERT INTO `t_relationships` VALUES ('20', '9');
INSERT INTO `t_relationships` VALUES ('20', '10');
INSERT INTO `t_relationships` VALUES ('20', '21');
INSERT INTO `t_relationships` VALUES ('20', '26');
INSERT INTO `t_relationships` VALUES ('21', '25');
INSERT INTO `t_relationships` VALUES ('21', '27');
INSERT INTO `t_relationships` VALUES ('22', '25');
INSERT INTO `t_relationships` VALUES ('22', '27');
INSERT INTO `t_relationships` VALUES ('23', '25');
INSERT INTO `t_relationships` VALUES ('23', '28');
INSERT INTO `t_relationships` VALUES ('24', '25');
INSERT INTO `t_relationships` VALUES ('24', '29');
INSERT INTO `t_relationships` VALUES ('25', '30');
INSERT INTO `t_relationships` VALUES ('25', '31');
INSERT INTO `t_relationships` VALUES ('26', '30');
INSERT INTO `t_relationships` VALUES ('26', '31');
INSERT INTO `t_relationships` VALUES ('27', '30');
INSERT INTO `t_relationships` VALUES ('27', '31');
INSERT INTO `t_relationships` VALUES ('28', '30');
INSERT INTO `t_relationships` VALUES ('28', '31');
INSERT INTO `t_relationships` VALUES ('29', '9');
INSERT INTO `t_relationships` VALUES ('29', '10');
INSERT INTO `t_relationships` VALUES ('29', '32');
INSERT INTO `t_relationships` VALUES ('29', '33');

-- ----------------------------
-- Table structure for t_users
-- ----------------------------
DROP TABLE IF EXISTS `t_users`;
CREATE TABLE `t_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `email` varchar(200) DEFAULT NULL,
  `home_url` varchar(200) DEFAULT NULL,
  `screen_name` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group_name` varchar(16) DEFAULT 'visitor',
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`username`),
  UNIQUE KEY `mail` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_users
-- ----------------------------
INSERT INTO `t_users` VALUES ('1', 'admin', 'dcfbb351cb35a5455e6f3bb11cb34cb0', '375027533@qq.com', null, 'admin', '1490756162', '0', '0', 'visitor');
